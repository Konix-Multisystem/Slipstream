# intel 80386SX
#
# Limitations of EDL mean the disassembler generation is partial, C side will have to fix some things up.
#
#
# Instructions are split across a few tables (but significantly fewer than the original implementation)
#
#
# Known issues	- Not every instruction is implemented
#		- All cycles counts are WRONG!!
#		- Trap is not implemented
#		- Real mode ONLY
#		- Most exceptions are not implemented
#		- External interface to memory is byte operations (although internally instructions use WORDS as appropriate)
#		- Mutliple interrupts are not guarded by priority - Konix system currently only implements video interrupt anyway
#		- Needs verifying!

C_FUNC_EXTERN	[32]	missing			[32];


C_FUNC_EXTERN	[8]	GetByte			[32];
# unsigned char GetByte(unsigned short);
#  Called when the cpu wants to read from memory
C_FUNC_EXTERN		SetByte			[32],[8];
# void SetByte(unsigned short,unsigned char);
#  Called when the cpu wants to write to memory
C_FUNC_EXTERN	[16]	GetPortW		[16];
# unsigned short GetPortW(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortW		[16],[16];
# void SetPortW(unsigned short,unsiged short);
#  Called when the cpu wants to write a word to an output port
C_FUNC_EXTERN	[8]	GetPortB		[16];
# unsigned short GetPortB(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortB		[16],[8];
# void SetPortB(unsigned short,unsiged short);
#  Called when the cpu wants to write a byte to an output port

DECLARE CYCLES[16];
DECLARE HALT[1];

############ Programmer registers
DECLARE EAX[32];
DECLARE EBX[32];
DECLARE ECX[32];
DECLARE	EDX[32];

DECLARE	ESP[32];
DECLARE	EBP[32];
DECLARE	ESI[32];
DECLARE	EDI[32];

DECLARE	CS[16];
DECLARE	DS[16];
DECLARE	SS[16];
DECLARE	ES[16];
DECLARE	FS[16];
DECLARE	GS[16];

DECLARE	EIP[32];

DECLARE	EFLAGS[32]	ALIAS	%00000000000000:VM[1]:RF[1]:%0:NT[1]:IOPL[2]:OF[1]:DF[1]:I[1]:TF[1]:SF[1]:ZF[1]:%0:AF[1]:%0:PF[1]:%1:CF[1];

############ Internal CPU state registers - should match hardware

DECLARE CR0[32]		ALIAS	%0000000000000000000000000000000:CR_PE[1];
DECLARE CR1[32];
DECLARE CR2[32];
DECLARE CR3[32];
DECLARE CR4[32];

DECLARE SegBase[[3]][32];
DECLARE SegLimit[[3]][32];

DECLARE SegCS[3]	ALIAS	%000;
DECLARE SegDS[3]	ALIAS	%001;
DECLARE SegES[3]	ALIAS	%010;
DECLARE SegFS[3]	ALIAS	%011;
DECLARE SegGS[3]	ALIAS	%100;
DECLARE SegSS[3]	ALIAS	%101;

############ Internal CPU state registers - doesn't match hardware

DECLARE INTERNAL GDT[48]	ALIAS	GDT_base[32]:GDT_limit[16];
DECLARE INTERNAL IDT[48]	ALIAS	IDT_base[32]:IDT_limit[16];

DECLARE INTERNAL cSize[1];		## Current Code Page size -- currrently 16bit always
DECLARE INTERNAL sSize[1];		## Current Stack Address size
DECLARE INTERNAL oSize[1];
DECLARE INTERNAL aSize[1];

DECLARE INTERNAL REPEAT[1];
DECLARE INTERNAL REPEATZ[1];
DECLARE INTERNAL SegOveride[1];
DECLARE INTERNAL SegOverideValue[16];
DECLARE INTERNAL SegOverideReg[3];

DECLARE INTERNAL interruptPending[1];
DECLARE INTERNAL interruptVector[8];

DECLARE INTERNAL IRQBlock[1];

DECLARE INTERNAL EXIP[32];		# Exceptions store this value rather than IP

############ Debug functions

FUNCTION addr[32] GETPHYSICAL_EIP
{
	IF CR_PE
	{
		addr<-SegBase[[SegCS]]+EIP;
	}
	IF ~CR_PE
	{
		DECLARE dummy[4];
		DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

		pageOffset<-CS;
		physical<-ROL(physical,dummy,%0000,4);
		addr<-physical+(EIP[0..15]);
	}
}

############ Helper functions

FUNCTION INTERNAL byte[8]	GetByteFromPhysicalAddress	segReg[3],segment[16],offset[32]
{
	IF CR_PE
	{
		byte<-CALL GetByte(SegBase[[segReg]]+offset);
	}
	IF ~CR_PE
	{
		DECLARE dummy[4];
		DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

		pageOffset<-segment;
		physical<-ROL(physical,dummy,%0000,4);
		physical<-physical+(offset[0..15]);
		byte<-CALL GetByte(physical);
	}
}

FUNCTION INTERNAL	SetByteAtPhysicalAddress	segReg[3],segment[16],offset[32],byte[8]
{
	IF CR_PE
	{
		CALL SetByte(SegBase[[segReg]]+offset,byte);
	}
	IF ~CR_PE
	{
		DECLARE dummy[4];
		DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

		pageOffset<-segment;
		physical<-ROL(physical,dummy,%0000,4);
		physical<-physical+(offset[0..15]);
		CALL SetByte(physical,byte);
	}
}

FUNCTION INTERNAL	StoreLongNoOveride	segReg[3],seg[16],off[32],lng[32]
{
	CALL SetByteAtPhysicalAddress(segReg,seg,off,lng[0..7]);
	CALL SetByteAtPhysicalAddress(segReg,seg,off+1,lng[8..15]);
	CALL SetByteAtPhysicalAddress(segReg,seg,off+2,lng[16..23]);
	CALL SetByteAtPhysicalAddress(segReg,seg,off+3,lng[24..31]);
}

FUNCTION INTERNAL	StoreWordNoOveride	segReg[3],seg[16],off[32],wrd[16]
{
	CALL SetByteAtPhysicalAddress(segReg,seg,off,wrd[0..7]);
	CALL SetByteAtPhysicalAddress(segReg,seg,off+1,wrd[8..15]);
}

FUNCTION INTERNAL	StoreByteNoOveride	segReg[3],seg[16],off[32],byt[8]
{
	CALL SetByteAtPhysicalAddress(segReg,seg,off,byt);
}

FUNCTION INTERNAL	StoreLong	segReg[3],seg[16],off[32],lng[32]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off,lng[0..7]);
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off+1,lng[8..15]);
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off+2,lng[16..23]);
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off+3,lng[24..31]);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(segReg,seg,off,lng[0..7]);
		CALL SetByteAtPhysicalAddress(segReg,seg,off+1,lng[8..15]);
		CALL SetByteAtPhysicalAddress(segReg,seg,off+2,lng[16..23]);
		CALL SetByteAtPhysicalAddress(segReg,seg,off+3,lng[24..31]);
	}
}

FUNCTION INTERNAL	StoreWord	segReg[3],seg[16],off[32],wrd[16]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off+1,wrd[8..15]);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(segReg,seg,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(segReg,seg,off+1,wrd[8..15]);
	}
}

FUNCTION INTERNAL	StoreByte	segReg[3],seg[16],off[32],byt[8]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideReg,SegOverideValue,off,byt);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(segReg,seg,off,byt);
	}
}

FUNCTION INTERNAL	wrd[16]		FetchWordNoOveride	segReg[3],seg[16],off[32]
{
	CALL GetByteFromPhysicalAddress(segReg,seg,off)->wrd[0..7];
	CALL GetByteFromPhysicalAddress(segReg,seg,off+1)->wrd[8..15];
}

FUNCTION INTERNAL	lng[32]		FetchLong		segReg[3],seg[16],off[32]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off)->lng[0..7];
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off+1)->lng[8..15];
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off+2)->lng[16..23];
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off+3)->lng[24..31];
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(segReg,seg,off)->lng[0..7];
		CALL GetByteFromPhysicalAddress(segReg,seg,off+1)->lng[8..15];
		CALL GetByteFromPhysicalAddress(segReg,seg,off+2)->lng[16..23];
		CALL GetByteFromPhysicalAddress(segReg,seg,off+3)->lng[24..31];
	}
}

FUNCTION INTERNAL	wrd[16]		FetchWord		segReg[3],seg[16],off[32]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off+1)->wrd[8..15];
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(segReg,seg,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(segReg,seg,off+1)->wrd[8..15];
	}
}

FUNCTION INTERNAL	byt[8]		FetchByte		segReg[3],seg[16],off[32]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideReg,SegOverideValue,off)->byt;
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(segReg,seg,off)->byt;
	}
}

FUNCTION INTERNAL	byt[8]		FetchByteNoOveride	segReg[3],seg[16],off[32]
{
	CALL GetByteFromPhysicalAddress(segReg,seg,off)->byt;
}

FUNCTION INTERNAL	PushWord	wrd[16]
{
	ESP<-ESP - 2;
	CALL StoreWordNoOveride(SegSS,SS,ESP,wrd);
}

FUNCTION INTERNAL	PushLong	lng[32]
{
	ESP<-ESP - 4;
	CALL StoreLongNoOveride(SegSS,SS,ESP,lng);
}

FUNCTION INTERNAL	lng[32]		PopLong
{
	CALL FetchWordNoOveride(SegSS,SS,ESP)->lng;
	ESP<-ESP + 4;
}

FUNCTION INTERNAL	wrd[16]		PopWord
{
	CALL FetchWordNoOveride(SegSS,SS,ESP)->wrd;
	ESP<-ESP + 2;
}

FUNCTION INTERNAL	byt[8]		GetImmediateByte
{
	CALL GetByteFromPhysicalAddress(SegCS,CS,EIP) -> byt;
	EIP + 1 -> EIP[0..15];
}

FUNCTION INTERNAL	wrd[16]		GetImmediateWord
{
	CALL GetImmediateByte() -> wrd[0..7];
	CALL GetImmediateByte() -> wrd[8..15];
}

FUNCTION INTERNAL	lng[32]		GetImmediateLong
{
	CALL GetImmediateWord() -> lng[0..15];
	CALL GetImmediateWord() -> lng[16..31];
}

FUNCTION INTERNAL	descriptor[64]	GetIDTEntry	offs[16]
{
	CALL GetByte(IDT_base+(offs*8)+0)->descriptor[0..7];
	CALL GetByte(IDT_base+(offs*8)+1)->descriptor[8..15];
	CALL GetByte(IDT_base+(offs*8)+2)->descriptor[16..23];
	CALL GetByte(IDT_base+(offs*8)+3)->descriptor[24..31];
	CALL GetByte(IDT_base+(offs*8)+4)->descriptor[32..39];
	CALL GetByte(IDT_base+(offs*8)+5)->descriptor[40..47];
	CALL GetByte(IDT_base+(offs*8)+6)->descriptor[48..55];
	CALL GetByte(IDT_base+(offs*8)+7)->descriptor[56..63];
}

FUNCTION INTERNAL	descriptor[64]	GetGDTEntry	offs[16]
{
	CALL GetByte(GDT_base+offs+0)->descriptor[0..7];
	CALL GetByte(GDT_base+offs+1)->descriptor[8..15];
	CALL GetByte(GDT_base+offs+2)->descriptor[16..23];
	CALL GetByte(GDT_base+offs+3)->descriptor[24..31];
	CALL GetByte(GDT_base+offs+4)->descriptor[32..39];
	CALL GetByte(GDT_base+offs+5)->descriptor[40..47];
	CALL GetByte(GDT_base+offs+6)->descriptor[48..55];
	CALL GetByte(GDT_base+offs+7)->descriptor[56..63];
}

FUNCTION INTERNAL	SetSegByDescriptor	segReg[3],seg[16],idescriptor[64]
{
	DECLARE descriptor[64]	ALIAS	baseHi[8]:Gran[1]:Use[1]:rsrv1[1]:rsrv2[1]:limitHi[4]:present[1]:priv[2]:desBit[1]:exe[1]:dir[1]:rw[1]:accessed[1]:baseLo[24]:limitLo[16];
	DECLARE	base[32] ALIAS bHi[8]:bLo[24];
	DECLARE limit[32] ALIAS lHi[12]:lMi[4]:lLo[16];

	descriptor<-idescriptor;

	bHi<-baseHi;
	bLo<-baseLo;
	lMi<-limitHi;
	lLo<-limitLo;

	IF Gran
	{
		limit<-limit*4096;
		limit<-limit|$00000FFF;
	}

	DEBUG_TRACE BASE 16,base,limit,Gran,Use,present,priv,desBit,exe,dir,rw,accessed;

	SegBase[[segReg]]<-base;
	SegLimit[[segReg]]<-limit;

	IF segReg==SegSS
	{
		sSize<-Use;
	}
	IF segReg==SegCS
	{
		IF Use
		{
			DEBUG_TRACE "CS load from 32 bit segment - TODO";
			CALL missing(0);
		}
	}
}

FUNCTION INTERNAL 		Exception			vector[8]
{
	IF CR_PE
	{
		DECLARE idescriptor[64]	ALIAS	offsHi[16]:present[1]:priv[2]:storage[1]:type[4]:%00000000:selector[16]:offsLo[16];
		DECLARE	offs[32] ALIAS oHi[16]:oLo[16];

		idescriptor<-CALL GetIDTEntry(vector);

		IF type!=6
		{
			DEBUG_TRACE "Non I16 interrupt descriptor!!";
			CALL missing(0);
		}

		oHi<-offsHi;
		oLo<-offsLo;
		
		CALL PushWord(EFLAGS);
		I<-0;
		CALL PushWord(CS);
		CALL PushWord(EXIP);

		DEBUG_TRACE BASE 16,idescriptor,offs,present,priv,storage,type,selector;

		CALL SetSegByDescriptor(SegCS,selector,CALL GetGDTEntry(selector));
		EIP<-offs;
	}
	IF ~CR_PE
	{
		DECLARE TMP[16];
		CALL PushWord(EFLAGS);
		I<-0;
		CALL PushWord(CS);
		CALL PushWord(EXIP);
		TMP<-vector*$0004;
		CALL FetchWordNoOveride(SegCS,$0000,TMP)->EIP;
		CALL FetchWordNoOveride(SegCS,$0000,TMP+2)->CS;

		51+CYCLES->CYCLES;
	}
}



############ CPU Step/Reset/Interrupt 

FUNCTION INTERNAL	DoExecute	IR[8]				#Workaround for bug in table generation when more than one execute exists in 2 different instructions
{
	EXECUTE IR;
}

FUNCTION STEP
{
	DECLARE	IR[8];

	SegOveride<-0;
	oSize<-cSize;		# Going to need to look these up per segment!
	aSize<-cSize;
	CYCLES<-0;
	IRQBlock<-0;

	IF ~interruptPending
	{
		IF ~HALT
		{
			IR<-CALL GetByteFromPhysicalAddress(SegCS,CS,EIP);
			EXIP<-EIP;					# CACHE IP FOR EXCEPTION/REPEAT HANDLING
			EIP<-EIP+1;

			CALL DoExecute(IR);
		}
		IF HALT
		{
			2+CYCLES->CYCLES;
		}
	}

#	IF interruptPending
#	{
#		HALT<-0;
#		interruptPending<-0;
#		# Standard interrupt procedure
#		CALL PushWord(FLAGS);
#		I<-0;
#		CALL PushWord(CS);
#		CALL PushWord(IP);
#		DECLARE TMP[16];
#		DECLARE dummy[2];
#		TMP<-interruptVector;
#		TMP<-ROL(TMP,dummy,%0000,2);
#		CALL FetchWordNoOveride($0000,TMP)->IP;
#		CALL FetchWordNoOveride($0000,TMP+2)->CS;
#
#		61+CYCLES->CYCLES;
#	}

}

#FUNCTION INTERRUPT	vector[8]
#{
#	#Flag interrupt pending (if interrupts enabled or NMI) -- Interrupt will occur at next possible cpu step
#	IF I & (~IRQBlock)
#	{
#		interruptPending<-1;
#		interruptVector<-vector;
#	}
#}

FUNCTION RESET
{
	interruptPending<-0;
	IRQBlock<-0;
	REPEAT<-0;
	EIP<-$FFF0;
	CS<-$F000;
	DS<-0;
	SS<-0;
	ES<-0;
	EFLAGS<-0;
	HALT<-0;
	CR_PE<-0;
	cSize<-0;
	sSize<-0;
	SegBase[[SegCS]]<-$FFFF0000;
	SegLimit[[SegCS]]<-$0000FFFF;
	SegBase[[SegDS]]<-$00000000;
	SegLimit[[SegDS]]<-$0000FFFF;
	SegBase[[SegES]]<-$00000000;
	SegLimit[[SegES]]<-$0000FFFF;
	SegBase[[SegFS]]<-$00000000;
	SegLimit[[SegFS]]<-$0000FFFF;
	SegBase[[SegGS]]<-$00000000;
	SegLimit[[SegGS]]<-$0000FFFF;
	SegBase[[SegSS]]<-$00000000;
	SegLimit[[SegSS]]<-$0000FFFF;
}

############# Various Mappings

MAPPING	flags[4]
{
#	%1000	"CLC"	CF<-0;
#	%0101	"CMC"	CF<-~C;
#	%1001	"STC"	CF<-1;
	%1010	"CLI"	I<-0;
	%1100	"CLD"	DF<-0;
#	%1101	"STD"	DF<-1;
}

#MAPPING	regl[3]
#{
#	%000	"AL"	AL;
#	%001	"CL"	CL;
#	%010	"DL"	DL;
#	%011	"BL"	BL;
#	%100	"AH"	AH;
#	%101	"CH"	CH;
#	%110	"DH"	DH;
#	%111	"BH"	BH;
#}
#
#MAPPING	reglop2[3]
#{
#	%000	"AL"	AL;
#	%001	"CL"	CL;
#	%010	"DL"	DL;
#	%011	"BL"	BL;
#	%100	"AH"	AH;
#	%101	"CH"	CH;
#	%110	"DH"	DH;
#	%111	"BH"	BH;
#}

MAPPING	regw[3]
{
	%000	"AX"	EAX[0..15];
	%001	"CX"	ECX[0..15];
	%010	"DX"	EDX[0..15];
	%011	"BX"	EBX[0..15];
	%100	"SP"	ESP[0..15];
	%101	"BP"	EBP[0..15];
	%110	"SI"	ESI[0..15];
	%111	"DI"	EDI[0..15];
}

#MAPPING	regwop2[3]
#{
#	%000	"AX"	AX;
#	%001	"CX"	CX;
#	%010	"DX"	DX;
#	%011	"BX"	BX;
#	%100	"SP"	SP;
#	%101	"BP"	BP;
#	%110	"SI"	SI;
#	%111	"DI"	DI;
#}
#

MAPPING cond[4]
{
	%0000	"O"	OF;
	%0001	"NO"	~OF;
	%0010	"C"	CF;
	%0011	"AE"	~CF;
	%0100	"E"	ZF;
	%0101	"NE"	~ZF;
	%0110	"BE"	CF | ZF;
	%0111	"A"	(~CF) & (~ZF);
	%1000	"S"	SF;
	%1001	"NS"	~SF;
	%1010	"P"	PF;
	%1011	"PO"	~PF;
	%1100	"L"	SF!=OF;
	%1101	"GE"	SF==OF;
	%1110	"LE"	ZF | (SF!=OF);
	%1111	"G"	(~ZF) & (SF==OF);
}

MAPPING accword[1]
{
	%0	"AL"	0;
	%1	"AX"	1;
}

MAPPING portVariable[1]
{
	%0	"#PORT#"	0;
	%1	"DX"		1;
}

#MAPPING DecIncB[1]
#{
#	%0	"INC"	CALL IncrementByte(T);
#	%1	"DEC"	CALL DecrementByte(T);
#}
#
#MAPPING DecIncW[1]
#{
#	%0	"INC"	CALL IncrementWord(T);
#	%1	"DEC"	CALL DecrementWord(T);
#}

MAPPING loopcond[2]
{
	%00	"NZ"	(~ZF);
	%01	"Z"	ZF;
	%10	""	1;
}

############# Table executors
#
##### Prefix operations

FUNCTION INTERNAL SetSegmentOveride	reg[3]
{
	IF reg==%000
	{
		SegOverideValue<-ES;
		SegOverideReg<-SegES;
		SegOveride<-1;
	}
	IF reg==%001
	{
		SegOverideValue<-CS;
		SegOverideReg<-SegCS;
		SegOveride<-1;
	}
	IF reg==%010
	{
		SegOverideValue<-SS;
		SegOverideReg<-SegSS;
		SegOveride<-1;
	}
	IF reg==%011
	{
		SegOverideValue<-DS;
		SegOverideReg<-SegDS;
		SegOveride<-1;
	}
	IF reg==%100
	{
		SegOverideValue<-FS;
		SegOverideReg<-SegFS;
		SegOveride<-1;
	}
	IF reg==%101
	{
		SegOverideValue<-GS;
		SegOverideReg<-SegGS;
		SegOveride<-1;
	}
}

INSTRUCTION	"XX001__110(Segment Overide %M0)"	%001:regs[2]:%110
{
	DECLARE IR[8];

	CALL SetSegmentOveride(regs);
	IR<-CALL GetImmediateByte();
	CALL DoExecute(IR);
	2+CYCLES->CYCLES;
}

INSTRUCTION	"SegFS"					%01100100
{
	DECLARE IR[8];

	CALL SetSegmentOveride(%100);
	IR<-CALL GetImmediateByte();
	CALL DoExecute(IR);
	2+CYCLES->CYCLES;
}

INSTRUCTION	"SegGS"					%01100101
{
	DECLARE IR[8];

	CALL SetSegmentOveride(%101);
	IR<-CALL GetImmediateByte();
	CALL DoExecute(IR);
	2+CYCLES->CYCLES;
}

INSTRUCTION	"OSIZE"					%01100110
{
	DECLARE IR[8];
	oSize<-~cSize;
	IR<-CALL GetImmediateByte();
	CALL DoExecute(IR);
	2+CYCLES->CYCLES;
}

INSTRUCTION	"ASIZE"					%01100111
{
	DECLARE IR[8];
	aSize<-~cSize;
	IR<-CALL GetImmediateByte();
	CALL DoExecute(IR);
	2+CYCLES->CYCLES;
}

#
MAPPING repne[1]
{
	%0	"NE"	%0;
	%1	"E"	%1;
}

FUNCTION INTERNAL	proceed[1]	DoRepeat
{
	IF ~REPEAT
	{
		proceed<-1;
	}
	IF REPEAT
	{
		IF aSize
		{
			DEBUG_TRACE "REPEAT aSize";
			CALL missing(0);
		}
		IF ~aSize
		{
			IF ((ECX[0..15])==0)
			{
				9+CYCLES->CYCLES;
				REPEAT<-0;
				proceed<-0;
			}
			IF ((ECX[0..15])!=0)
			{
				(ECX[0..15]) - 1->ECX[0..15];
				2+CYCLES->CYCLES;
				proceed<-1;
			}
		}
	}
}

INSTRUCTION	"REP%M0"	%1111001:repne,B2[8]			# interrupts must not fire on this prefix code
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
		
	REPEAT<-1;
	REPEATZ<-repne;

	CALL DoExecute(IR);
}

##### Unimplemented
#
## INT3    11001100
## WAIT    10011011
## ESC     11011xxx modxxxrm
## LOCK    11110000
#
#####
##### Instruction Helper functions
#####

FUNCTION INTERNAL	res[8]		GetByteRegister		reg[3]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		res<-EAX[0..7];
	}
	IF reg==%001
	{
		res<-ECX[0..7];
	}
	IF reg==%010
	{
		res<-EDX[0..7];
	}
	IF reg==%011
	{
		res<-EBX[0..7];
	}
	IF reg==%100
	{
		res<-EAX[8..15];
	}
	IF reg==%101
	{
		res<-ECX[8..15];
	}
	IF reg==%110
	{
		res<-EDX[8..15];
	}
	IF reg==%111
	{
		res<-EBX[8..15];
	}
}

FUNCTION INTERNAL	res[16]		GetWordRegister		reg[3]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		res<-EAX[0..15];
	}
	IF reg==%001
	{
		res<-ECX[0..15];
	}
	IF reg==%010
	{
		res<-EDX[0..15];
	}
	IF reg==%011
	{
		res<-EBX[0..15];
	}
	IF reg==%100
	{
		res<-ESP[0..15];
	}
	IF reg==%101
	{
		res<-EBP[0..15];
	}
	IF reg==%110
	{
		res<-ESI[0..15];
	}
	IF reg==%111
	{
		res<-EDI[0..15];
	}
}


FUNCTION INTERNAL	res[32]		GetLongRegister		reg[3]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		res<-EAX;
	}
	IF reg==%001
	{
		res<-ECX;
	}
	IF reg==%010
	{
		res<-EDX;
	}
	IF reg==%011
	{
		res<-EBX;
	}
	IF reg==%100
	{
		res<-ESP;
	}
	IF reg==%101
	{
		res<-EBP;
	}
	IF reg==%110
	{
		res<-ESI;
	}
	IF reg==%111
	{
		res<-EDI;
	}
}

FUNCTION INTERNAL	SetByteRegister		reg[3],val[8]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		val->EAX[0..7];
	}
	IF reg==%001
	{
		val->ECX[0..7];
	}
	IF reg==%010
	{
		val->EDX[0..7];
	}
	IF reg==%011
	{
		val->EBX[0..7];
	}
	IF reg==%100
	{
		val->EAX[8..15];
	}
	IF reg==%101
	{
		val->ECX[8..15];
	}
	IF reg==%110
	{
		val->EDX[8..15];
	}
	IF reg==%111
	{
		val->EBX[8..15];
	}
}

FUNCTION INTERNAL	SetWordRegister		reg[3],val[16]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		val->EAX[0..15];
	}
	IF reg==%001
	{
		val->ECX[0..15];
	}
	IF reg==%010
	{
		val->EDX[0..15];
	}
	IF reg==%011
	{
		val->EBX[0..15];
	}
	IF reg==%100
	{
		val->ESP[0..15];
	}
	IF reg==%101
	{
		val->EBP[0..15];
	}
	IF reg==%110
	{
		val->ESI[0..15];
	}
	IF reg==%111
	{
		val->EDI[0..15];
	}
}

FUNCTION INTERNAL	SetLongRegister		reg[3],val[32]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		val->EAX;
	}
	IF reg==%001
	{
		val->ECX;
	}
	IF reg==%010
	{
		val->EDX;
	}
	IF reg==%011
	{
		val->EBX;
	}
	IF reg==%100
	{
		val->ESP;
	}
	IF reg==%101
	{
		val->EBP;
	}
	IF reg==%110
	{
		val->ESI;
	}
	IF reg==%111
	{
		val->EDI;
	}
}

FUNCTION INTERNAL	SetControlRegister		reg[3],val[32]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		val->CR0;
	}
	IF reg==%001
	{
		val->CR1;
	}
	IF reg==%010
	{
		val->CR2;
	}
	IF reg==%011
	{
		val->CR3;
	}
	IF reg==%100
	{
		val->CR4;
	}
}

FUNCTION INTERNAL	SetSegmentRegister		reg[3],val[16]		## Because we can't look up arbitrary mappings in EDL at moment
{
	DECLARE seg[16];
	DECLARE SegReg[3];

	val->seg;
	IF reg==%000
	{
		val->ES;
		SegES->SegReg;
	}
	IF reg==%001
	{
		DEBUG_TRACE "Illegal SetRegCS";
		CALL missing(0);
	}
	IF reg==%010
	{
		val->SS;
		SegSS->SegReg;
	}
	IF reg==%011
	{
		val->DS;
		SegDS->SegReg;
	}
	IF reg==%100
	{
		val->FS;
		SegFS->SegReg;
	}
	IF reg==%101
	{
		val->GS;
		SegGS->SegReg;
	}
	IF reg>%101
	{
		DEBUG_TRACE "SetSeg ",reg;
		CALL missing(0);
	}
	IF CR_PE
	{
		CALL SetSegByDescriptor(SegReg,seg,CALL GetGDTEntry(seg));
	}
}

FUNCTION INTERNAL	val[16]	GetSegmentRegister		reg[3]		## Because we can't look up arbitrary mappings in EDL at moment
{
	IF reg==%000
	{
		ES->val;
	}
	IF reg==%001
	{
		CS->val;
	}
	IF reg==%010
	{
		SS->val;
	}
	IF reg==%011
	{
		DS->val;
	}
	IF reg>%011
	{
		DEBUG_TRACE "GetSeg ",reg;
		CALL missing(0);
	}
}

#
#FUNCTION INTERNAL	res[8]		IncrementByte		val[8]
#{
#	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(val,$01,7), P AS PARITYEVEN { val + 1 }->res;
#}
#
#FUNCTION INTERNAL	res[8]		DecrementByte		val[8]
#{
#	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(val,$01,7), P AS PARITYEVEN { val - 1 }->res;
#}

FUNCTION INTERNAL	res[16]		IncrementWord		val[16]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(val,$0001,15) { val + 1 }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[32]		IncrementLong		val[32]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(val,$00000001,31) { val + 1 }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		DecrementWord		val[16]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(val,$0001,15) { val - 1 }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[32]		DecrementLong		val[32]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(val,$00000001,31) { val - 1 }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[32]		AddLong			dst[32],src[32],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,31), CF AS CARRY(31) { (dst + src)+carry }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		AddWord			dst[16],src[16],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,15), CF AS CARRY(15) { (dst + src)+carry }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[8]		AddByte			dst[8],src[8],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,7), CF AS CARRY(7), PF AS PARITYEVEN { (dst + src)+carry }->res;
}

FUNCTION INTERNAL	res[32]		SubLong			dst[32],src[32],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,31), CF AS CARRY(31) { (dst - src)-carry }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		SubWord			dst[16],src[16],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,15), CF AS CARRY(15) { (dst - src)-carry }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[8]		SubByte			dst[8],src[8],carry[1]
{
	AFFECT SF AS SIGN, ZF AS ZERO, AF AS CARRY(3), OF AS OVERFLOW(dst,src,7), CF AS CARRY(7), PF AS PARITYEVEN { (dst - src)-carry }->res;
}

FUNCTION INTERNAL	res[32]		AndLong			dst[32],src[32]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst & src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		AndWord			dst[16],src[16]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst & src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[8]		AndByte			dst[8],src[8]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET, PF AS PARITYEVEN { dst & src }->res;
}

FUNCTION INTERNAL	res[32]		OrLong			dst[32],src[32]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst | src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		OrWord			dst[16],src[16]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst | src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[8]		OrByte			dst[8],src[8]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET, PF AS PARITYEVEN { dst | src }->res;
}

FUNCTION INTERNAL	res[32]		XorLong			dst[32],src[32]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst ^ src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[16]		XorWord			dst[16],src[16]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET { dst ^ src }->res;
	AFFECT PF AS PARITYEVEN { res[0..7] };
}

FUNCTION INTERNAL	res[8]		XorByte			dst[8],src[8]
{
	AFFECT SF AS SIGN, ZF AS ZERO, OF AS FORCERESET, CF AS FORCERESET, PF AS PARITYEVEN { dst ^ src }->res;
}

FUNCTION INTERNAL	res[16]		NegWord			val[16]
{
	res<-CALL SubWord($0000,val,0);
}

FUNCTION INTERNAL	res[8]		NegByte			val[8]
{
	res<-CALL SubByte($00,val,0);
}

#FUNCTION INTERNAL			IMulWord		src[16]					# No return, assigns value as intended by instruction implicitly
#{
#	DECLARE lhs[32];
#	DECLARE rhs[32];
#	DECLARE result[32]	ALIAS	upper[16]:lower[16];
#	lhs<-$00000000++AX;
#	rhs<-$00000000++src;
#	result<-lhs * rhs;
#	C<-~((upper==$0000) | (upper==$FFFF));
#	O<-C;
#	DX<-upper;
#	AX<-lower;
#}
#
#FUNCTION INTERNAL			IMulByte		src[8]					# No return, assigns value as intended by instruction implicitly
#{
#	DECLARE lhs[16];
#	DECLARE rhs[16];
#	DECLARE result[16]	ALIAS	upper[8]:lower[8];
#	lhs<-$0000++AL;
#	rhs<-$0000++src;
#	result<-lhs * rhs;
#	C<-~((upper==$00) | (upper==$FF));
#	O<-C;
#	
#	AX<-result;
#}

FUNCTION INTERNAL			MulLong			src[32]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[64];
	DECLARE rhs[64];
	DECLARE result[64]	ALIAS	upper[32]:lower[32];
	lhs<-EAX;
	rhs<-src;
	result<-lhs * rhs;
	CF<-upper!=$00000000;
	OF<-CF;
	EDX<-upper;
	EAX<-lower;
}

FUNCTION INTERNAL			MulWord			src[16]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[32];
	DECLARE rhs[32];
	DECLARE result[32]	ALIAS	upper[16]:lower[16];
	lhs<-EAX[0..15];
	rhs<-src;
	result<-lhs * rhs;
	CF<-upper!=$0000;
	OF<-CF;
	upper->EDX[0..15];
	lower->EAX[0..15];
}

FUNCTION INTERNAL			MulByte			src[8]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[16];
	DECLARE rhs[16];
	DECLARE result[16]	ALIAS	upper[8]:lower[8];
	lhs<-EAX[0..7];
	rhs<-src;
	result<-lhs * rhs;
	CF<-upper!=$00;
	OF<-CF;
	
	result->EAX[0..15];
}

FUNCTION INTERNAL			DivLong			src[32]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[64];
	DECLARE rhs[64];
	EDX->lhs[32..63];
	EAX->lhs[0..31];
	rhs<-src;
	IF rhs!=0
	{
		DECLARE quo[32];
		DECLARE rem[32];
		quo<-lhs / rhs;
		rem<-lhs % rhs;

		IF quo<=$FFFFFFFF
		{
			quo->EAX;
			rem->EDX;
		}
		IF quo>$FFFFFFFF
		{
			CALL Exception(0);
		}
	}
	IF rhs==0
	{
		CALL Exception(0);
	}
}

FUNCTION INTERNAL			DivWord			src[16]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[32];
	DECLARE rhs[32];
	EDX[0..15]->lhs[16..31];
	EAX[0..15]->lhs[0..15];
	rhs<-src;
	IF rhs!=0
	{
		DECLARE quo[32];
		DECLARE rem[32];
		quo<-lhs / rhs;
		rem<-lhs % rhs;

		IF quo<=$0000FFFF
		{
			quo->EAX[0..15];
			rem->EDX[0..15];
		}
		IF quo>$0000FFFF
		{
			CALL Exception(0);
		}
	}
	IF rhs==0
	{
		CALL Exception(0);
	}
}

FUNCTION INTERNAL			DivByte			src[8]					# No return, assigns value as intended by instruction implicitly
{
	DECLARE lhs[16];
	DECLARE rhs[16];
	lhs<-EAX[0..15];
	rhs<-src;
	IF rhs!=0
	{
		DECLARE quo[16];
		DECLARE rem[16];
		quo<-lhs / rhs;
		rem<-lhs % rhs;
		IF quo<=$00FF
		{
			quo->EAX[0..7];
			rem->EAX[8..15];
		}
		IF quo>$00FF
		{
			CALL Exception(0);
		}
	}
	IF rhs==0
	{
		CALL Exception(0);
	}
}

#FUNCTION INTERNAL			IDivWord		src[16]					# No return, assigns value as intended by instruction implicitly
#{
#	DECLARE lhs[32];
#	DECLARE rhs[32];
#	DX->lhs[16..31];
#	AX->lhs[0..15];
#	rhs<-$00000000++src;
#	IF rhs!=0
#	{
#		DECLARE quo[32];
#		DECLARE rem[32];
#		quo<-lhs // rhs;
#		rem<-lhs %% rhs;
#		IF (quo>=$FFFF8000) | (quo<=$00007FFF)
#		{
#			AX<-quo;
#			DX<-rem;
#		}
#		IF (quo<$FFFF8000) & (quo>$00007FFF)
#		{
#			CALL Exception(0);
#		}
#	}
#	IF rhs==0
#	{
#		CALL Exception(0);
#	}
#}
#
#FUNCTION INTERNAL			IDivByte		src[8]					# No return, assigns value as intended by instruction implicitly
#{
#	DECLARE lhs[16];
#	DECLARE rhs[16];
#	lhs<-AX;
#	rhs<-$0000++src;
#	IF rhs!=0
#	{
#		DECLARE quo[16];
#		DECLARE rem[16];
#		quo<-lhs // rhs;
#		rem<-lhs %% rhs;
#		IF (quo>=$FF80) | (quo<=$007F)
#		{
#			AL<-quo;
#			AH<-rem;
#		}
#		IF (quo<$FF80) & (quo>$007F)
#		{
#			CALL Exception(0);
#		}
#	}
#	IF rhs==0
#	{
#		CALL Exception(0);
#	}
#}

FUNCTION INTERNAL	EAS[51]		CalcEffectiveAddress32	eamod[2],earm[3],addcyc[8]		# Returns EAS which is SEFFECTIVE_SEGMENT_REGISTER[3]:EFFECTIVE_SEGMENT[16]:EFFECTIVE_ADDRESS[16] - Only for use with MOD=00,01,10 (11 is ignored)
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];
	DECLARE DISP[32];

	IF earm==%100		## SIB
	{
		DEBUG_TRACE "SIB required";
		CALL missing(0);
	}

	IF eamod==%00
	{
		DISP<-$00000000;
		IF earm==%101
		{
			DISP<-CALL GetImmediateLong();		# Special case - cycles adjusted at code check time
		}
	}
	IF eamod==%01
	{
		DISP<-$00000000++CALL GetImmediateByte();
		4+CYCLES->CYCLES;
	}
	IF eamod==%10
	{
		DISP<-CALL GetImmediateLong();
		4+CYCLES->CYCLES;
	}
	IF eamod==%11
	{
		# Do nothing, and don't adjust cycle count
	}
	IF eamod!=%11
	{
		addcyc+CYCLES->CYCLES;
		IF earm==%000
		{
			EAX+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			7+CYCLES->CYCLES;
		}
		IF earm==%001
		{
			ECX+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			8+CYCLES->CYCLES;
		}
		IF earm==%010
		{
			EDX+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			8+CYCLES->CYCLES;
		}
		IF earm==%011
		{
			EBX+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			7+CYCLES->CYCLES;
		}
		IF earm==%101
		{
			IF eamod==%00
			{
				DISP->EFF;
				DS->SEG;
				SegDS->SEGREG;
				6+CYCLES->CYCLES;
			}
			IF eamod!=%00
			{
				EBP+DISP->EFF;
				DS->SEG;
				SegDS->SEGREG;
				5+CYCLES->CYCLES;
			}
		}
		IF earm==%110
		{
			ESI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			5+CYCLES->CYCLES;
		}
		IF earm==%111
		{
			EDI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			5+CYCLES->CYCLES;
		}
	}

	EAS<-SEGEA;
}

FUNCTION INTERNAL	EAS[51]		CalcEffectiveAddress16	eamod[2],earm[3],addcyc[8]		# Returns EAS which is SEFFECTIVE_SEGMENT_REGISTER[3]:EFFECTIVE_SEGMENT[16]:EFFECTIVE_ADDRESS[32] - Only for use with MOD=00,01,10 (11 is ignored)
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:%0000000000000000:EFF[16];
	DECLARE DISP[16];

	IF eamod==%00
	{
		DISP<-$0000;
		IF earm==%110
		{
			DISP<-CALL GetImmediateWord();		# Special case - cycles adjusted at code check time
		}
	}
	IF eamod==%01
	{
		DISP<-$0000++CALL GetImmediateByte();
		4+CYCLES->CYCLES;
	}
	IF eamod==%10
	{
		DISP<-CALL GetImmediateWord();
		4+CYCLES->CYCLES;
	}
	IF eamod==%11
	{
		# Do nothing, and don't adjust cycle count
	}
	IF eamod!=%11
	{
		addcyc+CYCLES->CYCLES;
		IF earm==%000
		{
			EBX+ESI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			7+CYCLES->CYCLES;
		}
		IF earm==%001
		{
			EBX+EDI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			8+CYCLES->CYCLES;
		}
		IF earm==%010
		{
			EBP+ESI+DISP->EFF;
			SS->SEG;
			SegSS->SEGREG;
			8+CYCLES->CYCLES;
		}
		IF earm==%011
		{
			EBP+EDI+DISP->EFF;
			SS->SEG;
			SegSS->SEGREG;
			7+CYCLES->CYCLES;
		}
		IF earm==%100
		{
			ESI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			5+CYCLES->CYCLES;
		}
		IF earm==%101
		{
			EDI+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			5+CYCLES->CYCLES;
		}
		IF earm==%110
		{
			IF eamod==%00
			{
				DISP->EFF;
				DS->SEG;
				SegDS->SEGREG;
				6+CYCLES->CYCLES;
			}
			IF eamod!=%00
			{
				EBP+DISP->EFF;
				SS->SEG;
				SegSS->SEGREG;
				5+CYCLES->CYCLES;
			}
		}
		IF earm==%111
		{
			EBX+DISP->EFF;
			DS->SEG;
			SegDS->SEGREG;
			5+CYCLES->CYCLES;
		}
	}

	EAS<-SEGEA;
}

FUNCTION INTERNAL	EAS[51]		CalcEffectiveAddress	eamod[2],earm[3],addcyc[8]		# Returns EAS which is SEFFECTIVE_SEGMENT_REGISTER[3]:EFFECTIVE_SEGMENT[16]:EFFECTIVE_ADDRESS[16] - Only for use with MOD=00,01,10 (11 is ignored)
{
	IF aSize
	{
		CALL CalcEffectiveAddress32(eamod,earm,addcyc)->EAS;
	}
	IF ~aSize
	{
		CALL CalcEffectiveAddress16(eamod,earm,addcyc)->EAS;
	}
}

FUNCTION INTERNAL	SetEffectiveAddressLong	eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32],long[32]
{
	IF eamod==%11
	{
		CALL SetLongRegister(earm,long);
	}
	IF eamod!=%11
	{
		CALL StoreLong(SEGREG,SEG,EFF,long);
	}
}

FUNCTION INTERNAL	SetEffectiveAddressWord	eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32],word[16]
{
	IF eamod==%11
	{
		CALL SetWordRegister(earm,word);
	}
	IF eamod!=%11
	{
		CALL StoreWord(SEGREG,SEG,EFF,word);
	}
}

FUNCTION INTERNAL	byte[8]		GetEffectiveAddressByte		eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32]
{
	IF eamod==%11
	{
		CALL GetByteRegister(earm)->byte;
	}
	IF eamod!=%11
	{
		CALL FetchByte(SEGREG,SEG,EFF)->byte;
	}
}

FUNCTION INTERNAL	word[16]	GetEffectiveAddressWord		eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32]
{
	IF eamod==%11
	{
		CALL GetWordRegister(earm)->word;
	}
	IF eamod!=%11
	{
		CALL FetchWord(SEGREG,SEG,EFF)->word;
	}
}

FUNCTION INTERNAL	long[32]	GetEffectiveAddressLong		eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32]
{
	IF eamod==%11
	{
		CALL GetLongRegister(earm)->long;
	}
	IF eamod!=%11
	{
		CALL FetchLong(SEGREG,SEG,EFF)->long;
	}
}

FUNCTION INTERNAL	fword[48]	GetEffectiveAddressFWord		SEGREG[3],SEG[16],EFF[32]
{
	CALL FetchWord(SEGREG,SEG,EFF)->fword[0..15];
	CALL FetchWord(SEGREG,SEG,EFF+2)->fword[16..31];
	CALL FetchWord(SEGREG,SEG,EFF+4)->fword[32..47];
}



FUNCTION INTERNAL	SetEffectiveAddressByte	eamod[2],earm[3],SEGREG[3],SEG[16],EFF[32],byte[8]
{
	IF eamod==%11
	{
		CALL SetByteRegister(earm,byte);
	}
	IF eamod!=%11
	{
		CALL StoreByte(SEGREG,SEG,EFF,byte);
	}
}


####
#### Implied/1/2/3 Byte opcode instructions
####

INSTRUCTION	"PUSH %M0"		%01010:reg[3]
{
	IF oSize
	{
		CALL PushLong(CALL GetLongRegister(reg));
	}
	IF ~oSize
	{
		CALL PushWord(CALL GetWordRegister(reg));
	}
	11+CYCLES->CYCLES;
}

INSTRUCTION	"PUSH %M0"		%000:regs[2]:%110
{
	CALL PushWord(CALL GetSegmentRegister(regs));
	10+CYCLES->CYCLES;
}

INSTRUCTION	"POP %M0"		%01011:reg[3]
{
	IF oSize
	{
		CALL SetLongRegister(reg,CALL PopLong());
	}
	IF ~oSize
	{
		CALL SetWordRegister(reg,CALL PopWord());
	}
	8+CYCLES->CYCLES;
}

INSTRUCTION	"POP ES"		%00000111
{
	CALL SetSegmentRegister(%000,CALL PopWord());
	8+CYCLES->CYCLES;
}

INSTRUCTION	"POP SS"		%00010111
{
	CALL SetSegmentRegister(%010,CALL PopWord());
	8+CYCLES->CYCLES;
}

INSTRUCTION	"POP DS"		%00011111
{
	CALL SetSegmentRegister(%011,CALL PopWord());
	8+CYCLES->CYCLES;
}

INSTRUCTION	"XCHG AX,%M0"		%10010:reg[3]
{
	IF oSize
	{
		DEBUG_TRACE "xchg long";
		CALL missing(0);
	}
	IF ~oSize
	{
		DECLARE tmp[16];
		CALL GetWordRegister(reg)->tmp;
		CALL SetWordRegister(reg,EAX[0..15]);
		tmp->EAX[0..15];
		3+CYCLES->CYCLES;
	}
}

INSTRUCTION	"IN %M1,%M0"		%1110:portVariable:%10:accword
{
	DECLARE port[16];

	IF oSize|aSize
	{
		DEBUG_TRACE "IN long";
		CALL missing(0);	
	}

	IF portVariable
	{
		port<-EDX[0..15];
		8+CYCLES->CYCLES;
	}
	IF ~portVariable
	{
		port<-CALL GetImmediateByte();
		10+CYCLES->CYCLES;
	}
	IF accword
	{
		CALL GetPortW(port)->EAX[0..15];
	}
	IF ~accword
	{
		CALL GetPortB(port)->EAX[0..7];
	}
}

INSTRUCTION	"OUT %M0,%M1"		%1110:portVariable:%11:accword
{
	DECLARE port[16];

	IF oSize|aSize
	{
		DEBUG_TRACE "OUT long";
		CALL missing(0);	
	}

	IF portVariable
	{
		port<-EDX[0..15];
		8+CYCLES->CYCLES;
	}
	IF ~portVariable
	{
		port<-CALL GetImmediateByte();
		10+CYCLES->CYCLES;
	}
	IF accword
	{
		CALL SetPortW(port,EAX);
	}
	IF ~accword
	{
		CALL SetPortB(port,EAX);
	}
}

#INSTRUCTION	"XLAT"			%11010111
#{
#	CALL FetchByte(DS,BX+AL)->AL;
#	11+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"LAHF"			%10011111
#{
#	FLAGS[0..7]->AH;
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"SAHF"			%10011110
#{
#	DECLARE TMP[16];
#	TMP<-FLAGS;
#	AH->TMP[0..7];			# Work around for EDL bug, FLAGS does not get masked if updating using bitrange
#	TMP->FLAGS;
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"PUSHF"			%10011100
#{
#	CALL PushWord(FLAGS);
#	10+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"POPF"			%10011101
#{
#	CALL PopWord()->FLAGS;
#	8+CYCLES->CYCLES;
#}

INSTRUCTION	"MOV #REGWB#,#IMM3#"	%1011:word[1]:reg[3]
{
	IF word
	{
		IF oSize
		{
			CALL SetLongRegister(reg,CALL GetImmediateLong());
		}
		IF ~oSize
		{
			CALL SetWordRegister(reg,CALL GetImmediateWord());
		}
	}
	IF ~word
	{
		CALL SetByteRegister(reg,CALL GetImmediateByte());
	}
	4+CYCLES->CYCLES;
}

INSTRUCTION	"MOV %M0,#ADDR#"	%1010000:accword
{
	DECLARE Addr[32];

	IF aSize
	{
		CALL GetImmediateLong()->Addr;
		DEBUG_TRACE "huh";
		CALL missing(0);
	}
	IF ~aSize
	{
		CALL GetImmediateWord()->Addr;
	}
	IF accword
	{
		IF oSize 
		{
			DEBUG_TRACE "MOV R,offs32";
			CALL missing(0);
		}
		CALL FetchWord(SegDS,DS,Addr)->EAX[0..15];
	}
	IF ~accword
	{
		CALL FetchByte(SegDS,DS,Addr)->EAX[0..7];
	}
	10+CYCLES->CYCLES;
}

INSTRUCTION	"MOV #ADDR#,%M0"	%1010001:accword
{
	DECLARE Addr[32];

	IF aSize
	{
		CALL GetImmediateLong()->Addr;
	}
	IF ~aSize
	{
		CALL GetImmediateWord()->Addr;
	}
	IF accword
	{
		IF oSize 
		{
			DEBUG_TRACE "MOV offs32,R";
			CALL missing(0);
		}
		CALL StoreWord(SegDS,DS,Addr,EAX[0..15]);
	}
	IF ~accword
	{
		CALL StoreByte(SegDS,DS,Addr,EAX[0..7]);
	}
	10+CYCLES->CYCLES;
}

INSTRUCTION	"ADD %M0,#IMM0#"	%0000010:accword
{
	IF accword
	{
		IF oSize
		{
			DEBUG_TRACE "32 bit mode todo --";
			CALL missing(0);
		}
		IF ~oSize
		{
			CALL AddWord(EAX[0..15],CALL GetImmediateWord(),0)->EAX[0..15];
		}
	}
	IF ~accword
	{
		CALL AddByte(EAX[0..7],CALL GetImmediateByte(),0)->EAX[0..7];
	}
	4+CYCLES->CYCLES;
}

#INSTRUCTION	"ADC %M0,#IMM0#"	%0001010:accword
#{
#	IF accword
#	{
#		CALL AddWord(AX,CALL GetImmediateWord(),C)->AX;
#	}
#	IF ~accword
#	{
#		CALL AddByte(AL,CALL GetImmediateByte(),C)->AL;
#	}
#	4+CYCLES->CYCLES;
#}

INSTRUCTION	"INC %M0"		%01000:reg[3]
{
	IF oSize
	{
		CALL SetLongRegister(reg,CALL IncrementLong(CALL GetLongRegister(reg)));
	}
	IF ~oSize
	{
		CALL SetWordRegister(reg,CALL IncrementWord(CALL GetWordRegister(reg)));
	}
	2+CYCLES->CYCLES;
}

INSTRUCTION	"SUB %M0,#IMM0#"	%0010110:accword
{
	IF accword
	{
		IF oSize
		{
			DEBUG_TRACE "32 bit mode todo --";
			CALL missing(0);
		}
		IF ~oSize
		{
			CALL SubWord(EAX[0..15],CALL GetImmediateWord(),0)->EAX[0..15];
		}
	}
	IF ~accword
	{
		CALL SubByte(EAX[0..7],CALL GetImmediateByte(),0)->EAX[0..7];
	}
	4+CYCLES->CYCLES;
}

#INSTRUCTION	"SBB %M0,#IMM0#"	%0001110:accword
#{
#	IF accword
#	{
#		CALL SubWord(AX,CALL GetImmediateWord(),C)->AX;
#	}
#	IF ~accword
#	{
#		CALL SubByte(AL,CALL GetImmediateByte(),C)->AL;
#	}
#	4+CYCLES->CYCLES;
#}

INSTRUCTION	"DEC %M0"		%01001:reg[3]
{
	IF oSize
	{
		CALL SetLongRegister(reg,CALL DecrementLong(CALL GetLongRegister(reg)));
	}
	IF ~oSize
	{
		CALL SetWordRegister(reg,CALL DecrementWord(CALL GetWordRegister(reg)));
	}
	2+CYCLES->CYCLES;
}

INSTRUCTION	"CMP %M0,#IMM0#"	%0011110:accword
{
	IF accword
	{
		IF oSize
		{
			DEBUG_TRACE "CMP lng";
			CALL missing(0);
		}
		IF ~oSize
		{
			CALL SubWord(EAX[0..15],CALL GetImmediateWord(),0);
		}
	}
	IF ~accword
	{
		CALL SubByte(EAX[0..7],CALL GetImmediateByte(),0);
	}
	4+CYCLES->CYCLES;
}

#INSTRUCTION	"AAA"			%00110111
#{
#	IF ((AL & $0F) > 9) | A
#	{
#		AL+$06->AL;
#		AH+$01->AH;
#		C<-1;
#		A<-1;
#	}
#	IF ~(((AL & $0F) > 9) | A)
#	{
#		C<-0;
#		A<-0;
#	}
#	AL & $0F->AL;
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"DAA"			%00100111
#{
#	DECLARE Modifier[8];
#
#	IF A | ((AL[0..3])>9)
#	{
#		Modifier<-6;
#	}
#	IF C | (AL>$99)
#	{
#		Modifier<-Modifier | $60;
#		C<-1;
#	}
#
#	AFFECT S AS SIGN,Z AS ZERO,A AS CARRY(3),O AS OVERFLOW(AL,Modifier,7),P AS PARITYEVEN { AL + Modifier }->AL;
#
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"DAS"			%00101111
#{
#	DECLARE Modifier[8];
#
#	IF A | ((AL[0..3])>9)
#	{
#		Modifier<-6;
#	}
#	IF C | (AL>$99)
#	{
#		Modifier<-Modifier | $60;
#		C<-1;
#	}
#
#	AFFECT S AS SIGN,Z AS ZERO,A AS CARRY(3),O AS OVERFLOW(AL,Modifier,7),P AS PARITYEVEN { AL - Modifier }->AL;
#
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"AAD #IMM8#"		%11010101
#{
#	DECLARE TMP[8];
#	CALL GetImmediateByte()->TMP;
#	CALL AddByte(AH*TMP,AL,0)->AL;
#	$00->AH;
#	60+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"AAM #IMM8#"		%11010100
#{
#	DECLARE TMP[8];
#	CALL GetImmediateByte()->TMP;
#	IF TMP!=0
#	{
#		AL / TMP ->AH;
#		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN,O AS FORCERESET,C AS FORCERESET,A AS FORCERESET {AL % TMP }->AL;
#		83+CYCLES->CYCLES;
#	}
#	IF TMP==0
#	{
#		CALL Exception(0);
#	}
#}
#
#INSTRUCTION	"AAS"			%00111111
#{
#	IF ((AL & $0F) > 9) | A
#	{
#		AL-$06->AL;
#		AH-$01->AH;
#		C<-1;
#		A<-1;
#	}
#	IF ~(((AL & $0F) > 9) | A)
#	{
#		C<-0;
#		A<-0;
#	}
#	AL & $0F->AL;
#	4+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"CBW"			%10011000
#{
#	AX<-$0000++AL;
#	2+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"CWD"			%10011001
#{
#	DECLARE TMP[32] ALIAS UPPER[16]:LOWER[16];
#	TMP<-$00000000++AX;
#	DX<-UPPER;
#	5+CYCLES->CYCLES;
#}

INSTRUCTION	"AND %M0,#IMM0#"	%0010010:accword
{
	IF accword
	{
		IF oSize
		{
			CALL AndLong(EAX,CALL GetImmediateLong())->EAX;
		}
		IF ~oSize
		{
			CALL AndWord(EAX[0..15],CALL GetImmediateWord())->EAX[0..15];
		}
	}
	IF ~accword
	{
		CALL AndByte(EAX[0..7],CALL GetImmediateByte())->EAX[0..7];
	}
	4+CYCLES->CYCLES;
}

INSTRUCTION	"TEST %M0,#IMM0#"	%1010100:accword
{
	IF accword
	{
		IF oSize
		{
			CALL AndLong(EAX,CALL GetImmediateLong());
		}
		IF ~oSize
		{
			CALL AndWord(EAX[0..15],CALL GetImmediateWord());
		}
	}
	IF ~accword
	{
		CALL AndByte(EAX[0..7],CALL GetImmediateByte());
	}
	4+CYCLES->CYCLES;
}

INSTRUCTION	"OR %M0,#IMM0#"		%0000110:accword
{
	IF accword
	{
		IF oSize
		{
			CALL OrLong(EAX,CALL GetImmediateLong())->EAX;
		}
		IF ~oSize
		{
			CALL OrWord(EAX[0..15],CALL GetImmediateWord())->EAX[0..15];
		}
	}
	IF ~accword
	{
		CALL OrByte(EAX[0..7],CALL GetImmediateByte())->EAX[0..7];
	}
	4+CYCLES->CYCLES;
}

INSTRUCTION	"XOR %M0,#IMM0#"	%0011010:accword
{
	IF accword
	{
		IF oSize
		{
			CALL XorLong(EAX,CALL GetImmediateLong())->EAX;
		}
		IF ~oSize
		{
			CALL XorWord(EAX[0..15],CALL GetImmediateWord())->EAX[0..15];
		}
	}
	IF ~accword
	{
		CALL XorByte(EAX[0..7],CALL GetImmediateByte())->EAX[0..7];
	}
	4+CYCLES->CYCLES;
}

#INSTRUCTION	"MOVS%M0"		%1010010:wrdbyte
#{
#	IF CALL DoRepeat()
#	{
#		DECLARE adjust[16];
#
#		IF wrdbyte
#		{
#			DECLARE TMP[16];
#			CALL FetchWord(DS,SI)->TMP;
#			CALL StoreWordNoOveride(ES,DI,TMP);
#			adjust<-2;
#		}
#		IF ~wrdbyte
#		{
#			DECLARE TMP[8];
#			CALL FetchByte(DS,SI)->TMP;
#			CALL StoreByteNoOveride(ES,DI,TMP);
#			adjust<-1;
#		}
#
#		IF D
#		{
#			adjust<-0-adjust;
#		}
#
#		SI<-SI+adjust;
#		DI<-DI+adjust;
#		IF ~REPEAT
#		{
#			18+CYCLES->CYCLES;
#		}
#		IF REPEAT
#		{
#			REPEAT<-0;
#			IP<-EXIP;
#			17+CYCLES->CYCLES;
#		}
#	}
#}

INSTRUCTION	"LODS%M0"		%1010110:wrdbyte[1]
{
	IF CALL DoRepeat()
	{
		DECLARE adjust[16];

		IF wrdbyte
		{
			IF oSize
			{
				DEBUG_TRACE "oSize LODS";
				CALL missing(0);
			}
			IF aSize
			{
				CALL FetchWord(SegDS,DS,ESI)->EAX[0..15];
			}
			IF ~aSize
			{
				CALL FetchWord(SegDS,DS,ESI[0..15])->EAX[0..15];
			}
			adjust<-2;
		}
		IF ~wrdbyte
		{
			IF aSize
			{
				CALL FetchByte(SegDS,DS,ESI)->EAX[0..7];
			}
			IF ~aSize
			{
				CALL FetchByte(SegDS,DS,ESI[0..15])->EAX[0..7];
			}
			adjust<-1;
		}

		IF DF
		{
			adjust<-0-adjust;
		}

		IF aSize
		{
			ESI+adjust->ESI;
		}
		IF ~aSize
		{
			(ESI[0..15])+adjust->ESI[0..15];
		}
		IF ~REPEAT
		{
			12->CYCLES;
		}
		IF REPEAT
		{
			REPEAT<-0;
			EIP<-EXIP;
			13+CYCLES->CYCLES;
		}
	}
}

INSTRUCTION	"STOS%M0"		%1010101:wrdbyte[1]
{
	IF CALL DoRepeat()
	{
		DECLARE adjust[16];

		IF wrdbyte
		{
			IF oSize
			{
				DEBUG_TRACE "oSize STOS";
				CALL missing(0);
			}
			IF aSize
			{
				CALL StoreWordNoOveride(SegES,ES,EDI,EAX[0..15]);
			}
			IF ~aSize
			{
				CALL StoreWordNoOveride(SegES,ES,EDI[0..15],EAX[0..15]);
			}
			adjust<-2;
		}
		IF ~wrdbyte
		{
			IF aSize
			{
				CALL StoreByteNoOveride(SegES,ES,EDI,EAX[0..7]);
			}
			IF ~aSize
			{
				CALL StoreByteNoOveride(SegES,ES,EDI[0..15],EAX[0..7]);
			}
			adjust<-1;
		}

		IF DF
		{
			adjust<-0-adjust;
		}

		IF aSize
		{
			EDI+adjust->EDI;
		}
		IF ~aSize
		{
			(EDI[0..15])+adjust->EDI[0..15];
		}
		IF ~REPEAT
		{
			11+CYCLES->CYCLES;
		}
		IF REPEAT
		{
			REPEAT<-0;
			EIP<-EXIP;
			10+CYCLES->CYCLES;
		}
	}
}

#INSTRUCTION	"CMPS%M0"		%1010011:wrdbyte
#{
#	IF CALL DoRepeat()
#	{
#		DECLARE adjust[16];
#
#		IF wrdbyte
#		{
#			CALL SubWord(CALL FetchWord(DS,SI),CALL FetchWordNoOveride(ES,DI),0);
#			adjust<-2;
#		}
#		IF ~wrdbyte
#		{
#			CALL SubByte(CALL FetchByte(DS,SI),CALL FetchByteNoOveride(ES,DI),0);
#			adjust<-1;
#		}
#
#		IF D
#		{
#			adjust<-0-adjust;
#		}
#
#		SI<-SI+adjust;
#		DI<-DI+adjust;
#		IF (~REPEAT) | (Z!=REPEATZ)
#		{
#			22+CYCLES->CYCLES;
#		}
#		IF REPEAT & (Z==REPEATZ)
#		{
#			REPEAT<-0;
#			IP<-EXIP;
#			22+CYCLES->CYCLES;
#		}
#	}
#}
#
#INSTRUCTION	"SCAS%M0"		%1010111:wrdbyte
#{
#	IF CALL DoRepeat()
#	{
#		DECLARE adjust[16];
#
#		IF wrdbyte
#		{
#			CALL SubWord(AX,CALL FetchWordNoOveride(ES,DI),0);
#			adjust<-2;
#		}
#		IF ~wrdbyte
#		{
#			CALL SubByte(AL,CALL FetchByteNoOveride(ES,DI),0);
#			adjust<-1;
#		}
#
#		IF D
#		{
#			adjust<-0-adjust;
#		}
#
#		DI<-DI+adjust;
#		IF (~REPEAT) | (Z!=REPEATZ)
#		{
#			15+CYCLES->CYCLES;
#		}
#		IF REPEAT & (Z==REPEATZ)
#		{
#			REPEAT<-0;
#			IP<-EXIP;
#			15+CYCLES->CYCLES;
#		}
#	}
#}

INSTRUCTION	"CALL #16DISP#"		%11101000
{
	DECLARE disp[16];

	IF oSize | aSize
	{
		DEBUG_TRACE "CALL long mode (16disp)";
		CALL missing(0);
	}

	disp<-CALL GetImmediateWord();
	CALL PushWord(EIP);
	EIP ++ disp->EIP;
	19+CYCLES->CYCLES;
}

INSTRUCTION	"CALL #FAR#"		%10011010
{
	IF oSize | aSize
	{
		DEBUG_TRACE "CALL FAR long mode";
		CALL missing(0);
	}

	DECLARE offset[16];
	DECLARE segment[16];
	offset<-CALL GetImmediateWord();
	segment<-CALL GetImmediateWord();
	CALL PushWord(CS);
	CALL PushWord(EIP);
	CS<-segment;
	EIP<-offset;
	28+CYCLES->CYCLES;
}

INSTRUCTION	"JMP #16DISP#"		%11101001
{
	IF ~CR_PE
	{
		DECLARE disp[16];
		disp<-CALL GetImmediateWord();
		EIP++disp->EIP[0..15];			##check for 16/32 mode
		15+CYCLES->CYCLES;
	}
	IF CR_PE
	{
		DEBUG_TRACE "TODO JMP DISP16 PE MODE";
		CALL missing(0);
	}
}

INSTRUCTION	"JMP #8DISP#"		%11101011
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	EIP<-EIP++disp;
	15+CYCLES->CYCLES;
}

INSTRUCTION	"JMP #FAR#"		%11101010
{
	IF ~CR_PE
	{
		DECLARE off[16];
		DECLARE seg[16];
		off<-CALL GetImmediateWord();
		seg<-CALL GetImmediateWord();
		EIP<-$00000000 | off;
		CS<-seg;
		15+CYCLES->CYCLES;
	}
	IF CR_PE
	{
		DECLARE off[16];
		DECLARE seg[16];
		off<-CALL GetImmediateWord();
		seg<-CALL GetImmediateWord();

		CALL SetSegByDescriptor(SegCS,seg,CALL GetGDTEntry(seg));

		EIP<-off;
		CS<-seg;
		15+CYCLES->CYCLES;
	}
}

INSTRUCTION	"RET"			%11000011
{
	EIP<-CALL PopWord();
	8+CYCLES->CYCLES;
}

#INSTRUCTION	"RET #IMM16#"		%11000010
#{
#	DECLARE TMP[16];
#	CALL GetImmediateWord()->TMP;
#	IP<-CALL PopWord();
#	SP<-SP+TMP;
#	12+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"RETF"			%11001011
#{
#	IP<-CALL PopWord();
#	CS<-CALL PopWord();
#	18+CYCLES->CYCLES;
#}
#
#INSTRUCTION	"RETF #IMM16#"		%11001010
#{
#	DECLARE TMP[16];
#	CALL GetImmediateWord()->TMP;
#	IP<-CALL PopWord();
#	CS<-CALL PopWord();
#	SP<-SP+TMP;
#	22+CYCLES->CYCLES;
#}

INSTRUCTION	"J%M0 #8DISP#"		%0111:cond
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	IF cond
	{
		EIP++disp->EIP;
		16+CYCLES->CYCLES;
	}
	IF ~cond
	{
		4+CYCLES->CYCLES;
	}
}

#INSTRUCTION	"JCXZ #8DISP#"		%11100011
#{
#	DECLARE disp[8];
#	disp<-CALL GetImmediateByte();
#	IF CX==0
#	{
#		IP<-IP++disp;
#		18+CYCLES->CYCLES;
#	}
#	IF CX!=0
#	{
#		6+CYCLES->CYCLES;
#	}
#}

INSTRUCTION	"LOOP%M0 #8DISP#"	%111000:loopcond
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	IF aSize
	{
		ECX-1->ECX;
		IF (ECX!=0) & (loopcond)
		{
			EIP++disp->EIP;
			17+CYCLES->CYCLES;
		}
		IF (ECX==0) & (~loopcond)
		{
			5+CYCLES->CYCLES;
		}
	}
	IF ~aSize
	{
		(ECX[0..15])-1->ECX[0..15];
		IF ((ECX[0..15])!=0) & (loopcond)
		{
			EIP++disp->EIP;
			17+CYCLES->CYCLES;
		}
		IF ((ECX[0..15])==0) & (~loopcond)
		{
			5+CYCLES->CYCLES;
		}
	}
}

INSTRUCTION	"INT #VECTOR#"		%11001101
{
	DECLARE TMP[8];

	TMP<-CALL GetImmediateByte();
	EXIP<-EIP;
	CALL Exception(TMP);
}

#INSTRUCTION	"INTO"			%11001110
#{
#	IF O
#	{
#		EXIP<-IP;
#		CALL Exception(4);
#	}
#	IF ~O
#	{
#		4+CYCLES->CYCLES;
#	}
#}

INSTRUCTION	"IRET"			%11001111
{
	CALL PopWord()->EIP[0..15];
	CALL PopWord()->CS;
	CALL PopWord()->EFLAGS[0..15];

	IF CR_PE
	{
		CALL SetSegByDescriptor(SegCS,CS,CALL GetGDTEntry(CS));
	}

	24+CYCLES->CYCLES;
}

INSTRUCTION	"%M0"			%1111:flags
{
	flags;
	2+CYCLES->CYCLES;
}

INSTRUCTION	"STI"			%11111011
{
	I<-1;
	IRQBlock<-1;
	2+CYCLES->CYCLES;
}

#INSTRUCTION	"HLT"			%11110100
#{
#	HALT<-1;
#	2+CYCLES->CYCLES;
#}

####
#### MOD nnn R/M instructions (immediate/implied register)
####

INSTRUCTION	"MOV #MODnnnRM#,#IMM0#"		%1100011:word[1]
{
	DECLARE IR[9]	ALIAS	wordOp[1]:Opcode[8];

	wordOp<-word;
	CALL GetImmediateByte()->Opcode;

	EXECUTE TABLE_MOV_MOD_IMM IR;
}

INSTRUCTION	TABLE_MOV_MOD_IMM	""		wordOp[1]:mod[2]:%000:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
	4+CYCLES->CYCLES;

	IF oSize | aSize
	{
		DEBUG_TRACE "MOV_MOD_IMM lng";
		CALL missing(0);
	}

	IF wordOp
	{
		CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL GetImmediateWord());
	}
	IF ~wordOp
	{
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL GetImmediateByte());
	}
}

#INSTRUCTION	"#TABLE2#"	%11111110
#{
#	DECLARE opcode[8];
#
#	CALL GetImmediateByte()->opcode;
#
#	EXECUTE TABLE_DECINC_MOD opcode;
#}
#
#INSTRUCTION	TABLE_DECINC_MOD	"%M0 #MODnnnRM#"	mod[2]:%00:DecIncB:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#	DECLARE T[8];
#
#	CALL CalcEffectiveAddress(mod,rm,12)->SEGEA;
#	3+CYCLES->CYCLES;
#
#	CALL GetEffectiveAddressByte(mod,rm,SEG,EFF)->T;
#
#	DecIncB->T;
#
#	CALL SetEffectiveAddressByte(mod,rm,SEG,EFF,T);
#}
#
#INSTRUCTION	"POP #MODnnnRM#"	%10001111
#{
#	DECLARE opcode[8];
#
#	CALL GetImmediateByte()->opcode;
#
#	EXECUTE TABLE_POP_MOD opcode;
#}
#
#INSTRUCTION	TABLE_POP_MOD		""		mod[2]:dc[3]:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,9)->SEGEA;
#	8+CYCLES->CYCLES;
#
#	CALL SetEffectiveAddressWord(mod,rm,SEG,EFF,CALL PopWord());
#}
#
##### MOD n SREG R/M instructions

INSTRUCTION	"MOV #MODSREGRM#"	%100011:direc[1]:0
{
	DECLARE IR[9]	ALIAS	direcOp[1]:opcode[8];

	direcOp<-direc;
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_MOV_MOD_SREG IR;
}

INSTRUCTION	TABLE_MOV_MOD_SREG	""		direcOp[1]:mod[2]:sreg[3]:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6+(1-direcOp))->SEGEA;
	2+CYCLES->CYCLES;

	IF direcOp
	{
		CALL SetSegmentRegister(sreg,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF));
	}
	IF ~direcOp
	{
		CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL GetSegmentRegister(sreg));
	}
}

##### MOD reg R/M instructions (2 operand)
#
#MAPPING leaMod[2]
#{
#	%00	""	%00;
#	%01	""	%01;
#	%10	""	%10;
#}
#
#INSTRUCTION	"LEA #MODleaRM#"			%10001101
#{
#	#MEM to Register - MOD=11 not allowed
#	# MOD(00,01,10) reg R/M
#	DECLARE IR[8];
#
#	CALL GetImmediateByte()->IR;
#
#	EXECUTE TABLE_LEA IR;
#}
#
#INSTRUCTION	TABLE_LEA	""		leaMod:regw:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(leaMod,rm,2)->SEGEA;
#	EFF->regw;
#}
#
#MAPPING LDESMap[1]
#{
#	%0	"ES"	%0;
#	%1	"DS"	%1;
#}
#
#MAPPING ldsReg[1]
#{
#	%0	"ES"	ES;
#	%1	"DS"	DS;
#}
#
#INSTRUCTION	"L%M0 #MODleaRM#"		%1100010:LDESMap
#{
#	DECLARE IR[9]	ALIAS	lds[1]:opcode[8];
#
#	CALL GetImmediateByte()->opcode;
#	LDESMap->lds;
#
#	EXECUTE TABLE_LDES IR;
#}
#
#INSTRUCTION	TABLE_LDES	""		ldsReg:leaMod:regw:rm[3]
#{
#	DECLARE	SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(leaMod,rm,16)->SEGEA;
#
#	CALL GetEffectiveAddressWord(leaMod,rm,SEG,EFF)->regw;
#	CALL GetEffectiveAddressWord(leaMod,rm,SEG,EFF+2)->ldsReg;
#}

MAPPING operationMapping[6]
{
%000000		"ADD"	$0;
%000100		"ADC"	$1;
%001010		"SUB"	$2;
%001000		"AND"	$3;
%000010		"OR"	$4;
%001100		"XOR"	$5;
%000110		"SBB"	$6;
}

FUNCTION INTERNAL	res[8]	DoOperationByte	operation[3],dst[8],src[8]
{
	IF operation==$0
	{
		CALL AddByte(dst,src,0)->res;
	}
	IF operation==$1
	{
		CALL AddByte(dst,src,CF)->res;
	}
	IF operation==$2
	{
		CALL SubByte(dst,src,0)->res;
	}
	IF operation==$3
	{
		CALL AndByte(dst,src)->res;
	}
	IF operation==$4
	{
		CALL OrByte(dst,src)->res;
	}
	IF operation==$5
	{
		CALL XorByte(dst,src)->res;
	}
	IF operation==$6
	{
		CALL SubByte(dst,src,CF)->res;
	}
}

FUNCTION INTERNAL	res[16]	DoOperationWord	operation[3],dst[16],src[16]
{
	IF operation==$0
	{
		CALL AddWord(dst,src,0)->res;
	}
	IF operation==$1
	{
		CALL AddWord(dst,src,CF)->res;
	}
	IF operation==$2
	{
		CALL SubWord(dst,src,0)->res;
	}
	IF operation==$3
	{
		CALL AndWord(dst,src)->res;
	}
	IF operation==$4
	{
		CALL OrWord(dst,src)->res;
	}
	IF operation==$5
	{
		CALL XorWord(dst,src)->res;
	}
	IF operation==$6
	{
		CALL SubWord(dst,src,CF)->res;
	}
}

FUNCTION INTERNAL	res[32]	DoOperationLong	operation[3],dst[32],src[32]
{
	IF operation==$0
	{
		CALL AddLong(dst,src,0)->res;
	}
	IF operation==$1
	{
		CALL AddLong(dst,src,CF)->res;
	}
	IF operation==$2
	{
		CALL SubLong(dst,src,0)->res;
	}
	IF operation==$3
	{
		CALL AndLong(dst,src)->res;
	}
	IF operation==$4
	{
		CALL OrLong(dst,src)->res;
	}
	IF operation==$5
	{
		CALL XorLong(dst,src)->res;
	}
	IF operation==$6
	{
		CALL SubLong(dst,src,CF)->res;
	}
}

FUNCTION INTERNAL	DoModReg	oper[3],direcOp[1],wordOp[1],mod[2],reg[3],rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6+((1-direcOp)*7))->SEGEA;
	3+CYCLES->CYCLES;

	IF direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL SetLongRegister(reg,CALL DoOperationLong(oper,CALL GetLongRegister(reg),CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF)));
			}
			IF ~oSize
			{
				CALL SetWordRegister(reg,CALL DoOperationWord(oper,CALL GetWordRegister(reg),CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF)));
			}
		}
		IF ~wordOp
		{
			CALL SetByteRegister(reg,CALL DoOperationByte(oper,CALL GetByteRegister(reg),CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF)));
		}
	}
	IF ~direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL SetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF,CALL DoOperationLong(oper,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF),CALL GetLongRegister(reg)));
			}
			IF ~oSize
			{
				CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL DoOperationWord(oper,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF),CALL GetWordRegister(reg)));
			}
		}
		IF ~wordOp
		{
			CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL DoOperationByte(oper,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF),CALL GetByteRegister(reg)));
		}
	}
}


INSTRUCTION	"%M0 #MODregRM#"	operationMapping:direc[1]:word[1]
{
	DECLARE IR[5]	ALIAS	oper[3]:direcOp[1]:wordOp[1];
	DECLARE opc[8]	ALIAS	mod[2]:reg[3]:rm[3];

	direcOp<-direc;
	wordOp<-word;
	oper<-operationMapping;

	CALL GetImmediateByte()->opc;

	CALL DoModReg(oper,direcOp,wordOp,mod,reg,rm);

}

INSTRUCTION	"CMP #MODregRM#"	%001110:direc[1]:word[1]
{
	DECLARE IR[10]	ALIAS	direcOp[1]:wordOp[1]:opcode[8];

	direcOp<-direc;
	wordOp<-word;

	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_CMP_MOD_REG IR;
}

INSTRUCTION	TABLE_CMP_MOD_REG	""	direcOp[1]:wordOp[1]:mod[2]:reg[3]:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
	3+CYCLES->CYCLES;

	IF direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL DoOperationLong($2,CALL GetLongRegister(reg),CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF));
			}
			IF ~oSize
			{
				CALL DoOperationWord($2,CALL GetWordRegister(reg),CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF));
			}
		}
		IF ~wordOp
		{
			CALL DoOperationByte($2,CALL GetByteRegister(reg),CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF));
		}
	}
	IF ~direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL DoOperationLong($2,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF),CALL GetLongRegister(reg));
			}
			IF ~oSize
			{
				CALL DoOperationWord($2,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF),CALL GetWordRegister(reg));
			}
		}
		IF ~wordOp
		{
			CALL DoOperationByte($2,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF),CALL GetByteRegister(reg));
		}
	}
}

FUNCTION INTERNAL MovModRM	direcOp[1],wordOp[1],mod[2],reg[3],rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6+(1-direcOp))->SEGEA;
	2+CYCLES->CYCLES;

	IF direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL SetLongRegister(reg,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF));
			}
			IF ~oSize
			{
				CALL SetWordRegister(reg,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF));
			}
		}
		IF ~wordOp
		{
			CALL SetByteRegister(reg,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF));
		}
	}
	IF ~direcOp
	{
		IF wordOp
		{
			IF oSize
			{
				CALL SetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF,CALL GetLongRegister(reg));
			}
			IF ~oSize
			{
				CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL GetWordRegister(reg));
			}
		}
		IF ~wordOp
		{
			CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL GetByteRegister(reg));
		}
	}
}


INSTRUCTION	"MOV #MODregRM#"	%100010:direc[1]:word[1]
{
	DECLARE IR[2]	ALIAS	direcOp[1]:wordOp[1];
	DECLARE opc[8]	ALIAS	mod[2]:reg[3]:rm[3];

	direcOp<-direc;
	wordOp<-word;

	CALL GetImmediateByte()->opc;

	CALL MovModRM(direc,word,mod,reg,rm);
}

#INSTRUCTION	"TEST #MODregRM#"	%1000010:word[1]
#{
#	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];
#
#	wordOp<-word;
#
#	CALL GetImmediateByte()->opcode;
#
#	EXECUTE TABLE_TEST_MOD_REG IR;
#}
#
#INSTRUCTION	TABLE_TEST_MOD_REG	""	wordOp[1]:mod[2]:reg[3]:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
#	3+CYCLES->CYCLES;
#
#	IF wordOp
#	{
#		CALL AndWord(CALL GetWordRegister(reg),CALL GetEffectiveAddressWord(mod,rm,SEG,EFF));
#	}
#	IF ~wordOp
#	{
#		CALL AndByte(CALL GetByteRegister(reg),CALL GetEffectiveAddressByte(mod,rm,SEG,EFF));
#	}
#}

INSTRUCTION	"XCHG #MODregRM#"	%1000011:word[1]
{
	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];

	wordOp<-word;

	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_XCHG_MOD_REG IR;
}

INSTRUCTION	TABLE_XCHG_MOD_REG	""	wordOp[1]:mod[2]:reg[3]:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,13)->SEGEA;
	4+CYCLES->CYCLES;

	IF wordOp
	{
		IF oSize
		{
			DEBUG_TRACE "XCHG MOD long";
			CALL missing(0);
		}
		IF ~oSize
		{
			DECLARE TMP1[16];
			DECLARE TMP2[16];
			CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF)->TMP1;
			CALL GetWordRegister(reg)->TMP2;
			CALL SetWordRegister(reg,TMP1);
			CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,TMP2);
		}
	}
	IF ~wordOp
	{
		DECLARE TMP1[8];
		DECLARE TMP2[8];
		CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF)->TMP1;
		CALL GetByteRegister(reg)->TMP2;
		CALL SetByteRegister(reg,TMP1);
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,TMP2);
	}
}

##### MOD nnn R/M instructions (sign word extension - opcode in following byte)
#

MAPPING signwordModOp[3]
{
	%000	"ADD"	$0;
	%001	"OR"	$4;
	%010	"ADC"	$1;
	%011	"SBB"	$6;
	%100	"AND"	$3;
	%101	"SUB"	$2;
	%110	"XOR"	$5;
#	%111	"CMP"			#Handle seperately due to timing/operation difference
}

MAPPING signword[2]
{
	%00	""	%00;
	%01	""	%01;
# 10 illegal
	%11	""	%11;
}

INSTRUCTION	"#TABLE4#"	%100000:signword
{
	DECLARE IR[10]	ALIAS	signOp[1]:wordOp[1]:opcode[8];

	signOp<-signword[1..1];
	wordOp<-signword[0..0];
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_OP_MOD_IMM IR;
}

INSTRUCTION	TABLE_OP_MOD_IMM	"%M0 #MODnnnRM#,#IMMSW#"		signOp[1]:wordOp[1]:mod[2]:signwordModOp:rm[3]
{
	DECLARE	IMM[16]		ALIAS	IMMHI[8]:IMMLO[8];
	DECLARE IMML[32];
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,13)->SEGEA;
	4+CYCLES->CYCLES;

	IF wordOp
	{
		IF oSize
		{
			IF signOp
			{
				$00000000++CALL GetImmediateByte()->IMML;
			}
			IF ~signOp
			{
				DEBUG_TRACE "non sign extended longword... how?";
				CALL missing(0);
#				CALL GetImmediateWord()->IMML;
			}

			CALL SetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF,CALL DoOperationLong(signwordModOp,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF),IMML));
		}
		IF ~oSize
		{
			IF signOp
			{
				$0000++CALL GetImmediateByte()->IMM;
			}
			IF ~signOp
			{
				CALL GetImmediateWord()->IMM;
			}

			CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL DoOperationWord(signwordModOp,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF),IMM));
		}
	}
	IF ~wordOp
	{
		CALL GetImmediateByte()->IMMLO;
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL DoOperationByte(signwordModOp,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF),IMMLO));
	}
}

#INSTRUCTION	TABLE_OP_MOD_IMM	"CMP #MODnnnRM#,#IMMSW#"		signOp[1]:wordOp[1]:mod[2]:%111:rm[3]		# CMP seperated out due to cycle count and no storage
#{
#	DECLARE	IMM[16]		ALIAS	IMMHI[8]:IMMLO[8];
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
#	4+CYCLES->CYCLES;
#
#	IF wordOp
#	{
#		IF signOp
#		{
#			$0000++CALL GetImmediateByte()->IMM;
#		}
#		IF ~signOp
#		{
#			CALL GetImmediateWord()->IMM;
#		}
#
#		CALL DoOperationWord($2,CALL GetEffectiveAddressWord(mod,rm,SEG,EFF),IMM);
#	}
#	IF ~wordOp
#	{
#		CALL GetImmediateByte()->IMMLO;
#		CALL DoOperationByte($2,CALL GetEffectiveAddressByte(mod,rm,SEG,EFF),IMMLO);
#	}
#}

MAPPING shift1ModOp[3]
{
	%000	"ROL"	$0;
	%001	"ROR"	$1;
	%010	"RCL"	$2;
	%011	"RCR"	$3;
	%100	"SHL"	$4;
	%101	"SHR"	$5;
## %110 Not part of set
	%111	"SAR"	$6;
}

FUNCTION INTERNAL	res[8]	Do1ShiftOperationByte	operation[4],dst[8]
{
	IF operation==$0			# ROL
	{
		res<-ROL(dst,CF,dst[7..7],1);
		OF<-CF^(res[7..7]);
	}
	IF operation==$1			# ROR
	{
		res<-ROR(dst,CF,dst[0..0],1);
		OF<-(res[6..6])^(res[7..7]);
	}
	IF operation==$2			# RCL
	{
		res<-ROL(dst,CF,CF,1);
		OF<-CF^(res[7..7]);
	}
	IF operation==$3			# RCR
	{
		res<-ROR(dst,CF,CF,1);
		OF<-res[7..7]^res[6..6];
	}
	IF operation==$4			# SHL/SAL
	{
		AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN { ROL(dst,CF,$00,1) }->res;
		OF<-~(CF==res[7..7]);
	}
	IF operation==$5			# SHR
	{
		OF<-dst[7..7];
		AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN { ROR(dst,CF,$00,1) }->res;
	}
	IF operation==$6			# SAR
	{
		AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN,OF AS FORCERESET { ROR(dst,CF,dst[7..7],1) }->res;
	}
}

FUNCTION INTERNAL	res[16]	Do1ShiftOperationWord	operation[4],dst[16]
{
	IF operation==$0			# ROL
	{
		res<-ROL(dst,CF,dst[15..15],1);
		OF<-CF^(res[15..15]);
	}
	IF operation==$1			# ROR
	{
		res<-ROR(dst,CF,dst[0..0],1);
		OF<-(res[14..14])^(res[15..15]);
	}
	IF operation==$2			# RCL
	{
		res<-ROL(dst,CF,CF,1);
		OF<-CF^(res[15..15]);
	}
	IF operation==$3			# RCR
	{
		res<-ROR(dst,CF,CF,1);
		OF<-(res[15..15])^(res[14..14]);
	}
	IF operation==$4			# SHL/SAL
	{
		AFFECT SF AS SIGN,ZF AS ZERO { ROL(dst,CF,$0000,1) }->res;
		AFFECT PF AS PARITYEVEN { res[0..7] };
		OF<-~(CF==(res[15..15]));
	}
	IF operation==$5			# SHR
	{
		OF<-dst[15..15];
		AFFECT SF AS SIGN,ZF AS ZERO { ROR(dst,CF,$0000,1) }->res;
		AFFECT PF AS PARITYEVEN { res[0..7] };
	}
	IF operation==$6			# SAR
	{
		AFFECT SF AS SIGN,ZF AS ZERO,OF AS FORCERESET { ROR(dst,CF,dst[15..15],1) }->res;
		AFFECT PF AS PARITYEVEN { res[0..7] };
	}
}

MAPPING shiftVarModOp[3]
{
	%000	"ROL"	$0;
	%001	"ROR"	$1;
	%010	"RCL"	$2;
	%011	"RCR"	$3;
	%100	"SHL"	$4;
	%101	"SHR"	$5;
## %110 Not part of set
	%111	"SAR"	$6;
}

FUNCTION INTERNAL	res[8]	DoVariableShiftOperationByte	operation[4],dst[8],ishCnt[8]
{
	DECLARE TMP[8];
	DECLARE fill[8];
	DECLARE dummy[8];
	DECLARE shCnt[8];

	shCnt<-ishCnt;
	CYCLES+((shCnt)*$0004)->CYCLES;
	TMP<-dst;

	IF operation==$0			# ROL
	{
		IF shCnt>0
		{
			DECLARE bug[8];					# Another compiler issue - ROL steals bits from the wrong end - so needs preshifting into the right slot
			shCnt<-shCnt % 8;
			bug<-ROR(TMP,dummy,0,8-shCnt);
			TMP<-ROL(TMP,dummy,bug,shCnt);
			CF<-TMP[0..0];
		}
		res<-TMP;
	}
	IF operation==$1			# ROR
	{
		IF shCnt>0
		{
			shCnt<-shCnt % 8;
			TMP<-ROR(TMP,dummy,TMP,shCnt);
			CF<-TMP[7..7];
		}
		res<-TMP;
	}
	IF operation==$2			# RCL
	{
		DECLARE tRot[9]	ALIAS	val[8]:carry[1];
		DECLARE bug[9];					# Another compiler issue - ROL steals bits from the wrong end - so needs preshifting into the right slot

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 9;
		bug<-ROR(tRot,dummy,0,9-shCnt);
		tRot<-ROL(tRot,dummy,bug,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$3			# RCR
	{
		DECLARE tRot[9]	ALIAS	val[8]:carry[1];

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 9;

		tRot<-ROR(tRot,dummy,tRot,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$4			# SHL/SAL
	{
		res<-TMP;
		IF shCnt>=9
		{
			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN,CF AS FORCERESET { $00 }->res;
		}
		IF (shCnt>0) & (shCnt<9)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROL(TMP,dummy,$00,shCnt);
			}

			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN { ROL(TMP,CF,$00,1) }->res;
		}
	}
	IF operation==$5			# SHR
	{
		res<-TMP;
		IF shCnt>=9
		{
			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN,CF AS FORCERESET { $00 }->res;
		}
		IF (shCnt>0) & (shCnt<9)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,$00,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN { ROR(TMP,CF,$00,1) }->res;
		}
	}
	IF operation==$6			# SAR
	{
		res<-TMP;
		IF TMP[7..7]==1
		{
			fill<-$FFFF;
		}
		IF TMP[7..7]==0
		{
			fill<-$0000;
		}
		IF shCnt>=9
		{
			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN,CF AS BIT(7) { fill }->res;
		}
		IF (shCnt>0) & (shCnt<9)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,fill,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO,PF AS PARITYEVEN { ROR(TMP,CF,fill,1) }->res;
		}
	}
}

FUNCTION INTERNAL	res[16]	DoVariableShiftOperationWord	operation[4],dst[16],ishCnt[8]
{
	DECLARE TMP[16];
	DECLARE fill[16];
	DECLARE dummy[16];
	DECLARE shCnt[8];

	shCnt<-ishCnt;
	CYCLES+(shCnt*$0004)->CYCLES;
	TMP<-dst;

	IF operation==$0			# ROL
	{
		IF shCnt>0
		{
			DECLARE bug[16];
			shCnt<-shCnt % 16;
			bug<-ROR(TMP,dummy,0,16-shCnt);
			TMP<-ROL(TMP,dummy,bug,shCnt);
			CF<-TMP[0..0];
		}
		res<-TMP;
	}
	IF operation==$1			# ROR
	{
		IF shCnt>0
		{
			shCnt<-shCnt % 16;
			TMP<-ROR(TMP,dummy,TMP,shCnt);
			CF<-TMP[15..15];
		}
		res<-TMP;
	}
	IF operation==$2			# RCL
	{
		DECLARE tRot[17]	ALIAS	val[16]:carry[1];
		DECLARE bug[17];

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 17;
		bug<-ROR(tRot,dummy,0,17-shCnt);
		tRot<-ROL(tRot,dummy,bug,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$3			# RCR
	{
		DECLARE tRot[17]	ALIAS	val[16]:carry[1];

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 17;

		tRot<-ROR(tRot,dummy,tRot,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$4			# SHL/SAL
	{
		res<-TMP;
		IF shCnt>=17
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS FORCERESET { $0000 }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<17)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROL(TMP,dummy,$0000,shCnt);
			}

			AFFECT SF AS SIGN,ZF AS ZERO { ROL(TMP,CF,$0000,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
	IF operation==$5			# SHR
	{
		res<-TMP;
		IF shCnt>=17
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS FORCERESET { $0000 }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<17)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,$0000,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO { ROR(TMP,CF,$0000,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
	IF operation==$6			# SAR
	{
		res<-TMP;
		IF (TMP[15..15])==1
		{
			fill<-$FFFF;
		}
		IF (TMP[15..15])==0
		{
			fill<-$0000;
		}
		IF shCnt>=17
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS BIT(15) { fill }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<17)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,fill,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO { ROR(TMP,CF,fill,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
}

FUNCTION INTERNAL	res[32]	DoVariableShiftOperationLong	operation[4],dst[32],ishCnt[8]
{
	DECLARE TMP[32];
	DECLARE fill[32];
	DECLARE dummy[32];
	DECLARE shCnt[8];

	shCnt<-ishCnt;
	CYCLES+(shCnt*$0004)->CYCLES;
	TMP<-dst;

	IF operation==$0			# ROL
	{
		IF shCnt>0
		{
			DECLARE bug[32];
			shCnt<-shCnt % 32;
			bug<-ROR(TMP,dummy,0,32-shCnt);
			TMP<-ROL(TMP,dummy,bug,shCnt);
			CF<-TMP[0..0];
		}
		res<-TMP;
	}
	IF operation==$1			# ROR
	{
		IF shCnt>0
		{
			shCnt<-shCnt % 32;
			TMP<-ROR(TMP,dummy,TMP,shCnt);
			CF<-TMP[31..31];
		}
		res<-TMP;
	}
	IF operation==$2			# RCL
	{
		DECLARE tRot[33]	ALIAS	val[32]:carry[1];
		DECLARE bug[33];

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 33;
		bug<-ROR(tRot,dummy,0,33-shCnt);
		tRot<-ROL(tRot,dummy,bug,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$3			# RCR
	{
		DECLARE tRot[33]	ALIAS	val[32]:carry[1];

		val<-TMP;
		carry<-CF;
		shCnt<-shCnt % 33;

		tRot<-ROR(tRot,dummy,tRot,shCnt);

		res<-val;
		CF<-carry;
	}
	IF operation==$4			# SHL/SAL
	{
		res<-TMP;
		IF shCnt>=33
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS FORCERESET { $00000000 }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<33)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROL(TMP,dummy,$00000000,shCnt);
			}

			AFFECT SF AS SIGN,ZF AS ZERO { ROL(TMP,CF,$00000000,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
	IF operation==$5			# SHR
	{
		res<-TMP;
		IF shCnt>=33
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS FORCERESET { $00000000 }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<33)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,$00000000,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO { ROR(TMP,CF,$00000000,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
	IF operation==$6			# SAR
	{
		res<-TMP;
		IF (TMP[31..31])==1
		{
			fill<-$FFFFFFFF;
		}
		IF (TMP[31..31])==0
		{
			fill<-$00000000;
		}
		IF shCnt>=33
		{
			AFFECT SF AS SIGN,ZF AS ZERO,CF AS BIT(31) { fill }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
		IF (shCnt>0) & (shCnt<33)
		{
			IF shCnt>1
			{
				shCnt<-shCnt-1;
				TMP<-ROR(TMP,dummy,fill,shCnt);
			}
			AFFECT SF AS SIGN,ZF AS ZERO { ROR(TMP,CF,fill,1) }->res;
			AFFECT PF AS PARITYEVEN { res[0..7] };
		}
	}
}


INSTRUCTION	"#TABLE5#"	%1101000:word[1]			# Single shifts
{
	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];

	wordOp<-word;
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_SH1_MOD IR;
}

INSTRUCTION	"#TABLE6#"	%1101001:word[1]			# Variable (CL) shifts
{
	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];

	wordOp<-word;
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_SHV_MOD IR;
}

INSTRUCTION	"#TABLEn#"	%1100000:word[1]			# Variable (immediate) shifts
{
	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];

	wordOp<-word;
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_SHVIMM_MOD IR;
}


INSTRUCTION	TABLE_SH1_MOD	"%M0 #MODnnnRM#,1"		wordOp[1]:mod[2]:shift1ModOp:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,13)->SEGEA;
	2+CYCLES->CYCLES;
		
	IF wordOp
	{
		IF oSize
		{
			DEBUG_TRACE "SH1 long";
			CALL missing(0);
		}
		IF ~oSize
		{
			CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL Do1ShiftOperationWord(shift1ModOp,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF)));
		}
	}
	IF ~wordOp
	{
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL Do1ShiftOperationByte(shift1ModOp,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF)));
	}
}

INSTRUCTION	TABLE_SHV_MOD	"%M0 #MODnnnRM#,CL"		wordOp[1]:mod[2]:shiftVarModOp:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,12)->SEGEA;
	8+CYCLES->CYCLES;
		
	IF wordOp
	{
		IF oSize
		{
			CALL SetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationLong(shiftVarModOp,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF),(ECX[0..7])&$1F));
		}
		IF ~oSize
		{
			CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationWord(shiftVarModOp,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF),(ECX[0..7])&$1F));
		}
	}
	IF ~wordOp
	{
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationByte(shiftVarModOp,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF),(ECX[0..7])&$1F));
	}
}

INSTRUCTION	TABLE_SHVIMM_MOD	"%M0 #MODnnnRM#,IMM"		wordOp[1]:mod[2]:shiftVarModOp:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,12)->SEGEA;
	8+CYCLES->CYCLES;

	IF wordOp
	{
		IF oSize
		{
			CALL SetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationLong(shiftVarModOp,CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF),(CALL GetImmediateByte())&$1F));
		}
		IF ~oSize
		{
			CALL SetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationWord(shiftVarModOp,CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF),(CALL GetImmediateByte())&$1F));
		}
	}
	IF ~wordOp
	{
		CALL SetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF,CALL DoVariableShiftOperationByte(shiftVarModOp,CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF),(CALL GetImmediateByte())&$1F));
	}
}


INSTRUCTION	"#TABLE7#"	%1111011:word[1]
{
	DECLARE IR[9]	ALIAS	wordOp[1]:opcode[8];

	wordOp<-word;
	CALL GetImmediateByte()->opcode;

	EXECUTE TABLE_SOP_MOD IR;
}

#INSTRUCTION	TABLE_SOP_MOD	"NEG #MODnnnRM#"		wordOp[1]:mod[2]:%011:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,13)->SEGEA;
#	3+CYCLES->CYCLES;
#		
#	IF wordOp
#	{
#		CALL SetEffectiveAddressWord(mod,rm,SEG,EFF,CALL NegWord(CALL GetEffectiveAddressWord(mod,rm,SEG,EFF)));
#	}
#	IF ~wordOp
#	{
#		CALL SetEffectiveAddressByte(mod,rm,SEG,EFF,CALL NegByte(CALL GetEffectiveAddressByte(mod,rm,SEG,EFF)));
#	}
#}
#
#INSTRUCTION	TABLE_SOP_MOD	"TEST #MODnnnRM#,#IMM0#"	wordOp[1]:mod[2]:%000:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
#	5+CYCLES->CYCLES;
#		
#	IF wordOp
#	{
#		CALL AndWord(CALL GetEffectiveAddressWord(mod,rm,SEG,EFF),CALL GetImmediateWord());
#	}
#	IF ~wordOp
#	{
#		CALL AndByte(CALL GetEffectiveAddressByte(mod,rm,SEG,EFF),CALL GetImmediateByte());
#	}
#}

INSTRUCTION	TABLE_SOP_MOD	"MUL #MODnnnRM#"		wordOp[1]:mod[2]:%100:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
	70+(wordOp*48)+CYCLES->CYCLES;										# 70-77 (118-133) cycles

	IF wordOp
	{
		IF oSize
		{
			CALL MulLong(CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF));
		}
		IF ~oSize
		{
			CALL MulWord(CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF));
		}
	}
	IF ~wordOp
	{
		CALL MulByte(CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF));
	}
}

#INSTRUCTION	TABLE_SOP_MOD	"IMUL #MODnnnRM#"		wordOp[1]:mod[2]:%101:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
#	80+(wordOp*48)+CYCLES->CYCLES;										# 80-98 (128-154) cycles
#
#	IF wordOp
#	{
#		CALL IMulWord(CALL GetEffectiveAddressWord(mod,rm,SEG,EFF));
#	}
#	IF ~wordOp
#	{
#		CALL IMulByte(CALL GetEffectiveAddressByte(mod,rm,SEG,EFF));
#	}
#}
#
#INSTRUCTION	TABLE_SOP_MOD	"NOT #MODnnnRM#"		wordOp[1]:mod[2]:%010:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,13)->SEGEA;
#	3+CYCLES->CYCLES;
#		
#	IF wordOp
#	{
#		CALL SetEffectiveAddressWord(mod,rm,SEG,EFF,~CALL GetEffectiveAddressWord(mod,rm,SEG,EFF));
#	}
#	IF ~wordOp
#	{
#		CALL SetEffectiveAddressByte(mod,rm,SEG,EFF,~CALL GetEffectiveAddressByte(mod,rm,SEG,EFF));
#	}
#}

INSTRUCTION	TABLE_SOP_MOD	"DIV #MODnnnRM#"		wordOp[1]:mod[2]:%110:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
	80+(wordOp*64)+CYCLES->CYCLES;										# 80-90 (144-162) cycles

	IF wordOp
	{
		IF oSize
		{
			CALL DivLong(CALL GetEffectiveAddressLong(mod,rm,SEGREG,SEG,EFF));
		}
		IF ~oSize
		{
			CALL DivWord(CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF));
		}
	}
	IF ~wordOp
	{
		CALL DivByte(CALL GetEffectiveAddressByte(mod,rm,SEGREG,SEG,EFF));
	}
}

#INSTRUCTION	TABLE_SOP_MOD	"IDIV #MODnnnRM#"		wordOp[1]:mod[2]:%111:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
#	101+(wordOp*64)+CYCLES->CYCLES;										# 101-112 (165-184) cycles
#
#	IF wordOp
#	{
#		CALL IDivWord(CALL GetEffectiveAddressWord(mod,rm,SEG,EFF));
#	}
#	IF ~wordOp
#	{
#		CALL IDivByte(CALL GetEffectiveAddressByte(mod,rm,SEG,EFF));
#	}
#}

INSTRUCTION	"#TABLE8#"	%11111111
{
	# Register/Memory (word)
	#     JMPFAR
	# MOD 101     R/M
	DECLARE IR[8];

	CALL GetImmediateByte()->IR;

	EXECUTE TABLE_OP_MOD IR;
}

#INSTRUCTION	TABLE_OP_MOD	"JMP #MODnnnRM#"	mod[2]:%100:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,7)->SEGEA;
#	11+CYCLES->CYCLES;
#
#	CALL GetEffectiveAddressWord(mod,rm,SEG,EFF)->IP;
#}

INSTRUCTION	TABLE_OP_MOD	"CALL #MODnnnRM#"	mod[2]:%010:rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	IF oSize | aSize
	{
		DEBUG_TRACE "CALL 32bit mode?";
		CALL missing(0);
	}

	CALL CalcEffectiveAddress(mod,rm,5)->SEGEA;
	16+CYCLES->CYCLES;

	CALL PushWord(EIP);
	CALL GetEffectiveAddressWord(mod,rm,SEGREG,SEG,EFF)->EIP[0..15];
}

#INSTRUCTION	TABLE_OP_MOD	"CALL FAR #MODnnnRM#"	mod[2]:%011:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,0)->SEGEA;
#	37+CYCLES->CYCLES;
#
#	CALL PushWord(CS);
#	CALL PushWord(IP);
#	CALL GetEffectiveAddressWord(mod,rm,SEG,EFF)->IP;
#	CALL GetEffectiveAddressWord(mod,rm,SEG,EFF+2)->CS;
#}
#
#INSTRUCTION	TABLE_OP_MOD	"%M0 #MODnnnRM#"	mod[2]:%00:DecIncW:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#	DECLARE T[16];
#
#	CALL CalcEffectiveAddress(mod,rm,12)->SEGEA;
#	3+CYCLES->CYCLES;
#
#	CALL GetEffectiveAddressWord(mod,rm,SEG,EFF)->T;
#
#	DecIncW->T;
#
#	CALL SetEffectiveAddressWord(mod,rm,SEG,EFF,T);
#}
#
#INSTRUCTION	TABLE_OP_MOD	"PUSH #MODnnnRM#"	mod[2]:%110:rm[3]
#{
#	DECLARE SEGEA[32]	ALIAS	SEG[16]:EFF[16];
#
#	CALL CalcEffectiveAddress(mod,rm,5)->SEGEA;
#	11+CYCLES->CYCLES;
#
#	CALL PushWord(CALL GetEffectiveAddressWord(mod,rm,SEG,EFF));
#}
#
#


## Group 0F

INSTRUCTION	"0F"	%00001111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE FTABLE IR;
	2+CYCLES->CYCLES;
}

FUNCTION INTERNAL 	Do0F01	mod[2],reg[3],rm[3]
{
	DECLARE SEGEA[51]	ALIAS	SEGREG[3]:SEG[16]:EFF[32];

	CALL CalcEffectiveAddress(mod,rm,6)->SEGEA;
	3+CYCLES->CYCLES;

	IF mod==%11
	{
		DEBUG_TRACE "unknown 0F 01 extension";
	}
	IF mod!=%11
	{
		IF reg==%010	#LGDT
		{
			GDT<-CALL GetEffectiveAddressFWord(SEGREG,SEG,EFF);
			DEBUG_TRACE "GDT Table ",BASE 16,GDT_limit," - ",GDT_base;
		}
		IF reg==%011	#LIDT
		{
			IDT<-CALL GetEffectiveAddressFWord(SEGREG,SEG,EFF);
			DEBUG_TRACE "IDT Table ",BASE 16,IDT_limit," - ",IDT_base;
		}
		IF (reg!=%010) & (reg!=%011)
		{
			DEBUG_TRACE "TODO 0F 01 ",reg;
			CALL missing(0);
		}
	}
	
	2+CYCLES->CYCLES;
}

INSTRUCTION	FTABLE	"Do0F01"	%00000001
{
	# Could be a few different instructions based on modrm byte that follows
	DECLARE mrm[8]	ALIAS	mod[2]:reg[3]:rm[3];

	mrm<-CALL GetImmediateByte();
		
	CALL Do0F01(mod,reg,rm);
}

INSTRUCTION	FTABLE	"MOV CRx"	%00100010
{
	# Could be a few different instructions based on modrm byte that follows
	DECLARE mrm[8]	ALIAS	mod[2]:reg[3]:rm[3];

	mrm<-CALL GetImmediateByte();
	
	IF reg<5
	{
		CALL SetControlRegister(reg,CALL GetLongRegister(rm));
	}
	IF reg>=5
	{
		DEBUG_TRACE "Illegal CR register",reg;
		CALL missing(0);
	}	

	4+CYCLES->CYCLES;
}


