# intel 8086
#
# Simplified - Relatively quickly knocked together - cycle counts are wrong for word boundary misalignment!
#

C_FUNC_EXTERN	[8]	GetByte			[32];
# unsigned char GetByte(unsigned short);
#  Called when the cpu wants to read from memory
C_FUNC_EXTERN		SetByte			[32],[8];
# void SetByte(unsigned short,unsigned char);
#  Called when the cpu wants to write to memory
C_FUNC_EXTERN	[16]	GetPortW		[16];
# unsigned short GetPortW(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortW		[16],[16];
# void SetPortW(unsigned short,unsiged short);
#  Called when the cpu wants to write a word to an output port
C_FUNC_EXTERN	[8]	GetPortB		[16];
# unsigned short GetPortB(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortB		[16],[8];
# void SetPortB(unsigned short,unsiged short);
#  Called when the cpu wants to write a byte to an output port

DECLARE CYCLES[8];

# Programmer registers
DECLARE AX[16]	ALIAS	AH[8]:AL[8];
DECLARE BX[16]	ALIAS	BH[8]:BL[8];
DECLARE CX[16]	ALIAS	CH[8]:CL[8];
DECLARE	DX[16]	ALIAS	DH[8]:DL[8];

DECLARE	SP[16];
DECLARE	BP[16];
DECLARE	SI[16];
DECLARE	DI[16];

DECLARE	CS[16];
DECLARE	DS[16];
DECLARE	SS[16];
DECLARE	ES[16];

DECLARE	IP[16];

DECLARE	FLAGS[16]	ALIAS	%0000:O[1]:D[1]:I[1]:T[1]:S[1]:Z[1]:%0:A[1]:%0:P[1]:%0:C[1];		#

############

DECLARE INTERNAL REPEAT[1];
DECLARE INTERNAL EA[16];
DECLARE INTERNAL EAdisp[16];

DECLARE INTERNAL SegOveride[1];
DECLARE INTERNAL SegOverideValue[16];

DECLARE INTERNAL interruptPending[1];
DECLARE INTERNAL interruptVector[8];

############

FUNCTION INTERNAL byte[8]	GetByteFromPhysicalAddress	segment[16],offset[16]
{
	DECLARE dummy[4];
	DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

	pageOffset<-segment;
	physical<-ROL(physical,dummy,%0000,4);
	physical<-physical+offset;
	byte<-CALL GetByte(physical);
}

FUNCTION INTERNAL	SetByteAtPhysicalAddress	segment[16],offset[16],byte[8]
{
	DECLARE dummy[4];
	DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

	pageOffset<-segment;
	physical<-ROL(physical,dummy,%0000,4);
	physical<-physical+offset;
	CALL SetByte(physical,byte);
}

FUNCTION INTERNAL	StoreWord	seg[16],off[16],wrd[16]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideValue,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(SegOverideValue,off+1,wrd[8..15]);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(seg,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(seg,off+1,wrd[8..15]);
	}
}

FUNCTION INTERNAL	StoreByte	seg[16],off[16],byt[8]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideValue,off,byt);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(seg,off,byt);
	}
}

FUNCTION INTERNAL	wrd[16]		FetchWord		seg[16],off[16]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideValue,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(SegOverideValue,off+1)->wrd[8..15];
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(seg,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(seg,off+1)->wrd[8..15];
	}
}

FUNCTION INTERNAL	byt[8]		FetchByte		seg[16],off[16]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideValue,off)->byt;
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(seg,off)->byt;
	}
}

FUNCTION INTERNAL	PushWord	wrd[16]
{
	SP<-SP - 1;
	CALL SetByteAtPhysicalAddress(SS,SP,wrd[8..15]);
	SP<-SP - 1;
	CALL SetByteAtPhysicalAddress(SS,SP,wrd[0..7]);
}

FUNCTION INTERNAL	wrd[16]		PopWord
{
	CALL GetByteFromPhysicalAddress(SS,SP) -> wrd[0..7];
	SP<-SP + 1;
	CALL GetByteFromPhysicalAddress(SS,SP) -> wrd[8..15];
	SP<-SP + 1;
}

FUNCTION INTERNAL	byt[8]		GetImmediateByte
{
	CALL GetByteFromPhysicalAddress(CS,IP) -> byt;
	IP<-IP+1;
}

FUNCTION INTERNAL	wrd[16]		GetImmediateWord
{
	CALL GetImmediateByte() -> wrd[0..7];
	CALL GetImmediateByte() -> wrd[8..15];
}

############

FUNCTION STEP
{
	DECLARE	IR[8];

	SegOveride<-0;

	IF (~interruptPending) | REPEAT
	{
		IR<-CALL GetByteFromPhysicalAddress(CS,IP);
		IP<-IP+1;

		EXECUTE	IR;
	}

	IF interruptPending & (~REPEAT)
	{
		interruptPending<-0;
		# Standard interrupt procedure
		CALL PushWord(FLAGS);
		I<-0;
		CALL PushWord(CS);
		CALL PushWord(IP);
		DECLARE TMP[16];
		DECLARE dummy[2];
		TMP<-interruptVector;
		TMP<-ROL(TMP,dummy,%0000,2);
		CALL FetchWord($0000,TMP)->IP;
		CALL FetchWord($0000,TMP+2)->CS;

		61->CYCLES;
	}

}

FUNCTION INTERRUPT	vector[8]
{
	#Flag interrupt pending (if interrupts enabled or NMI) -- Interrupt will occur at next possible cpu step
	IF I
	{
		interruptPending<-1;
		interruptVector<-vector;
	}
}

FUNCTION RESET
{
	interruptPending<-0;
	REPEAT<-0;
	IP<-0;
	CS<-$FFFF;
	DS<-0;
	SS<-0;
	ES<-0;
	FLAGS<-0;
}

############

MAPPING	flags[4]
{
	%1000	"CLC"	C<-0;
	%0101	"CMC"	C<-~C;
	%1001	"STC"	C<-1;
	%1100	"CLD"	D<-0;
	%1101	"STD"	D<-1;
	%1010	"CLI"	I<-0;
	%1011	"STI"	I<-1;
}

MAPPING	regl[3]
{
	%000	"AL"	AL;
	%001	"CL"	CL;
	%010	"DL"	DL;
	%011	"BL"	BL;
	%100	"AH"	AH;
	%101	"CH"	CH;
	%110	"DH"	DH;
	%111	"BH"	BH;
}

MAPPING	reglop2[3]
{
	%000	"AL"	AL;
	%001	"CL"	CL;
	%010	"DL"	DL;
	%011	"BL"	BL;
	%100	"AH"	AH;
	%101	"CH"	CH;
	%110	"DH"	DH;
	%111	"BH"	BH;
}

MAPPING	regw[3]
{
	%000	"AX"	AX;
	%001	"CX"	CX;
	%010	"DX"	DX;
	%011	"BX"	BX;
	%100	"SP"	SP;
	%101	"BP"	BP;
	%110	"SI"	SI;
	%111	"DI"	DI;
}

MAPPING	regwop2[3]
{
	%000	"AX"	AX;
	%001	"CX"	CX;
	%010	"DX"	DX;
	%011	"BX"	BX;
	%100	"SP"	SP;
	%101	"BP"	BP;
	%110	"SI"	SI;
	%111	"DI"	DI;
}

MAPPING regs[2]
{
	%00	"ES"	ES;
	%01	"CS"	CS;
	%10	"SS"	SS;
	%11	"DS"	DS;
}

INSTRUCTION	"XX001__110(Segment Overide %M0)"	%001:regs:%110
{
	DECLARE IR[8];
	SegOverideValue<-regs;
	SegOveride<-1;
	IR<-CALL GetImmediateByte();
	EXECUTE IR;
	2+CYCLES->CYCLES;
}

INSTRUCTION	"XX00000010"		%00000010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000010 IR;
}

INSTRUCTION	"XX00000011"		%00000011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000011 IR;
}

INSTRUCTION	"XX00001001"		%00001001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001001 IR;
}

INSTRUCTION	"XX00001010"		%00001010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001010 IR;
}

INSTRUCTION	"XX00001011"		%00001011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001011 IR;
}

INSTRUCTION	"XX00010011"		%00010011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00010011 IR;
}

INSTRUCTION	"XX00110010"		%00110010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110010 IR;
}

INSTRUCTION	"XX00110011"		%00110011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110011 IR;
}

INSTRUCTION	"XX00111010"		%00111010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111010 IR;
}

INSTRUCTION	"XX00111011"		%00111011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111011 IR;
}


INSTRUCTION	"XX10000000"		%10000000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000000 IR;
}

INSTRUCTION	"XX10000001"		%10000001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000001 IR;
}

INSTRUCTION	"XX10000011"		%10000011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000011 IR;
}

INSTRUCTION	"XX10000110"		%10000110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000110 IR;
}

INSTRUCTION	"XX10001001"		%10001001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001001 IR;
}

INSTRUCTION	"XX10001010"		%10001010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001010 IR;
}

INSTRUCTION	"XX10001011"		%10001011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001011 IR;
}

INSTRUCTION	"XX10001100"		%10001100
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001100 IR;
}

INSTRUCTION	"XX10001110"		%10001110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001110 IR;
}

INSTRUCTION	"XX11000110"		%11000110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11000110 IR;
}

INSTRUCTION	"XX11000111"		%11000111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11000111 IR;
}

INSTRUCTION	"XX11010000"		%11010000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010000 IR;
}

INSTRUCTION	"XX11010001"		%11010001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010001 IR;
}

INSTRUCTION	"XX11010010"		%11010010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010010 IR;
}

INSTRUCTION	"XX11010011"		%11010011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010011 IR;
}

INSTRUCTION	"XX11110110"		%11110110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11110110 IR;
}

INSTRUCTION	"XX11111110"		%11111110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11111110 IR;
}

INSTRUCTION	"XX11111111"		%11111111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11111111 IR;
}


######

INSTRUCTION	"%M0"	%1111:flags
{
	flags;
	2->CYCLES;
}

INSTRUCTION	"MOV %M0,#%$2%$1"	%10111:regw,B2[8],B3[8]
{
	regw<-CALL GetImmediateWord();
	4->CYCLES;
}

INSTRUCTION	XX10001110	"MOV %M0,%M1"	%110:regs:regw
{
	regs<-regw;
	2->CYCLES;
}

INSTRUCTION	"OUT #%$1,AL"		%11100110,B2[8]
{
	CALL SetPortB(CALL GetImmediateByte(),AL);
	10->CYCLES;
}

INSTRUCTION	"OUT #%$1,AX"		%11100111,B2[8]
{
	CALL SetPortW(CALL GetImmediateByte(),AX);
	10->CYCLES;
}

INSTRUCTION	XX00110011	"XOR %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw ^ regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	"INC %M0"	%01000:regw
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,$0001,15), P AS PARITYEVEN { regw + 1 }->regw;
	2->CYCLES;
}

INSTRUCTION	"MOV %M0,#%$1"	%10110:regl,B2[8]
{
	regl<-CALL GetImmediateByte();
	4->CYCLES;
}

INSTRUCTION	"CALL #%$2%$1"	%11101000,B2[8],B3[8]
{
	DECLARE disp[16];
	disp<-CALL GetImmediateWord();
	CALL PushWord(IP);
	IP<-IP ++ disp;
	19->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,%M1"	%11:regw:regwop2
{
	regw<-regwop2;
	2->CYCLES;
}

INSTRUCTION	"XCHG AX,%M0"	%10010:regw
{
	AX<->regw;
	3->CYCLES;
}

INSTRUCTION	"STOSW"		%10101011
{
	CALL StoreWord(ES,DI,AX);
	IF D==0
	{
		DI<-DI+2;
	}
	IF D==1
	{
		DI<-DI-2;
	}
	11->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		8->CYCLES;
	}
}

INSTRUCTION	"LOOP #%$1"		%11100010,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	CX<-CX-1;
	5->CYCLES;
	IF CX!=0
	{
		IP<-IP++disp;
		17->CYCLES;
	}
}

INSTRUCTION	"RET"		%11000011
{
	IP<-CALL PopWord();
	8->CYCLES;
}

INSTRUCTION	"REP(E)"	%11110011			# interrupts must not fire on this prefix code
{
	IF CX==0
	{
		9->CYCLES;
		IP <- IP + 1;
	}
	IF CX!=0
	{
		REPEAT<-1;
		CX<-CX - 1;
		2->CYCLES;
	}
}

INSTRUCTION	"JMP #%$1"	%11101011,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	IP<-IP++disp;
	15->CYCLES;
}

FUNCTION INTERNAL	cyc[8]	CalculateEA	code[3],disp[16]
{
	IF code==%000
	{
		cyc<-7;
		EA<-BX+SI+disp;
	}
	IF code==%001
	{
		cyc<-8;
		EA<-BX+DI+disp;
	}
	IF code==%010
	{
		cyc<-8;
		EA<-BP+SI+disp;
	}
	IF code==%011
	{
		cyc<-7;
		EA<-BP+DI+disp;
	}
	IF code==%100
	{
		cyc<-5;
		EA<-SI+disp;
	}
	IF code==%101
	{
		cyc<-5;
		EA<-DI+disp;
	}
	IF code==%110
	{
		cyc<-5;
		EA<-BP+disp;
	}
	IF code==%111
	{
		cyc<-5;
		EA<-BX+disp;
	}
}

MAPPING memmod[3]
{
	%000	"BX+SI"	CALL CalculateEA(%000,EAdisp);
	%001	"BX+DI"	CALL CalculateEA(%001,EAdisp);
	%010	"BP+SI"	CALL CalculateEA(%010,EAdisp);
	%011	"BP+DI"	CALL CalculateEA(%011,EAdisp);
	%100	"SI"	CALL CalculateEA(%100,EAdisp);
	%101	"DI"	CALL CalculateEA(%101,EAdisp);
	%110	"BP"	CALL CalculateEA(%110,EAdisp);
	%111	"BX"	CALL CalculateEA(%111,EAdisp);
}

MAPPING memmod00[3]
{
	%000	"BX+SI"	CALL CalculateEA(%000,EAdisp);
	%001	"BX+DI"	CALL CalculateEA(%001,EAdisp);
	%010	"BP+SI"	CALL CalculateEA(%010,EAdisp);
	%011	"BP+DI"	CALL CalculateEA(%011,EAdisp);
	%100	"SI"	CALL CalculateEA(%100,EAdisp);
	%101	"DI"	CALL CalculateEA(%101,EAdisp);
#	%110	"BP"	CALL CalculateEA(%110;
	%111	"BX"	CALL CalculateEA(%111,EAdisp);
}

INSTRUCTION	XX11000111 	"MOV [%M0],#%$2%$1"	%00000:memmod00,B2[8],B3[8]
{
	DECLARE T[16];
	T<-CALL GetImmediateWord();
	0->EAdisp;
	memmod00+10->CYCLES;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11000111 	"MOV [#%$2%$1],#%$4%$3"	%00000110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	T<-CALL GetImmediateWord();
	9+10->CYCLES;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX11000111 	"MOV [%M0+#%$1],#%$3%$2"	%01000:memmod00,B2[8],B3[8],B4[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	T<-CALL GetImmediateWord();
	memmod00+4+10->CYCLES;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10000011	"ADD %M0,#%$1"	%11000:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%M1]"	%00:regw:memmod00
{
	0->EAdisp;
	memmod00+8->CYCLES;
	CALL FetchWord(DS,EA)->regw;
}

INSTRUCTION	XX00000011	"ADD %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { regw + regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	XX10000001	"ADD %M0,#%$2%$1"	%11000:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%M1+#%$1]"	%01:regw:memmod00,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod00+4+8->CYCLES;
	CALL FetchWord(DS,EA)->regw;
}

INSTRUCTION	"LODSW"		%10101101
{
	CALL FetchWord(DS,SI)->AX;
	IF D==0
	{
		SI<-SI+2;
	}
	IF D==1
	{
		SI<-SI-2;
	}
	12->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		9->CYCLES;
	}
}

INSTRUCTION	XX00111011	"CMP %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { regw - regwop2 };
	3->CYCLES;
}

MAPPING cond[4]
{
	%0100	"E"	Z;
	%1100	"L"	S!=O;
	%1110	"LE"	Z | (S!=O);
	%0010	"C"	C;
	%0110	"BE"	C | Z;
	%1010	"P"	P;
	%0000	"O"	O;
	%1000	"S"	S;
	%0101	"NE"	~Z;
	%1101	"GE"	S==O;
	%1111	"G"	(~Z) & (S==O);
	%0011	"AE"	~C;
	%0111	"A"	(~C) & (~Z);
	%1011	"PO"	~P;
	%0001	"NO"	~O;
	%1001	"NS"	~S;
}

INSTRUCTION	"J%M0 %$1"	%0111:cond,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	4->CYCLES;
	IF cond
	{
		IP<-IP++disp;
		16->CYCLES;
	}
}

INSTRUCTION	XX10001001	"MOV [%M1],%M0"		%00:regw:memmod00
{
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL StoreWord(DS,EA,regw);
}

INSTRUCTION	XX10001001	"MOV [#%$2%$1],%M0"		%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	9+9->CYCLES;
	CALL StoreWord(DS,EAdisp,regw);
}

INSTRUCTION	"MOV [%$2%$1],AX"		%10100011
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	CALL StoreWord(DS,T,AX);
	10->CYCLES;
}

INSTRUCTION	"PUSH %M0"	%01010:regw
{
	CALL PushWord(regw);
	11->CYCLES;
}

INSTRUCTION	"PUSH %M0"	%000:regs:%110
{
	CALL PushWord(regs);
	10->CYCLES;
}

INSTRUCTION	"CMP AX,#%$2%$1"	%00111101,B2[8],B3[8]
{
	DECLARE T[16];
	T<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,T,15), C AS CARRY(15), P AS PARITYEVEN { AX - T };
	4->CYCLES;
}

INSTRUCTION	"CMP AL,#%$1"	%00111100,B2[8]
{
	DECLARE T[8];
	T<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,T,7), C AS CARRY(7), P AS PARITYEVEN { AL - T };
	4->CYCLES;
}

INSTRUCTION	XX10000110	"XCHG %M0,%M1"		%11:regl:reglop2
{
	regl<->reglop2;
	4->CYCLES;
}

INSTRUCTION	XX10000000	"CMP [%M0],#%$1"	%00111:memmod00,B2[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	TMP<-CALL GetImmediateByte();
	0->EAdisp;
	memmod00+10->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000001	"CMP %M0,#%$2%$1"	%11111:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP };
	4->CYCLES;
}

INSTRUCTION	XX10000011	"CMP [#%$2%$1],#%$3"	%00111:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	9+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	"POP %M0"	%01011:regw
{
	CALL PopWord()->regw;
	8->CYCLES;
}

INSTRUCTION	"POP %M0"	%000:regs:%111
{
	CALL PopWord()->regs;
	8->CYCLES;
}

INSTRUCTION	"IRET"		%11001111
{
	IP<-CALL PopWord();
	CS<-CALL PopWord();
	FLAGS<-CALL PopWord();
	24->CYCLES;
}

INSTRUCTION	"LODSB"		%10101100
{
	CALL FetchByte(DS,SI)->AL;
	IF D==0
	{
		SI<-SI+1;
	}
	IF D==1
	{
		SI<-SI-1;
	}
	12->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		9->CYCLES;
	}
}

INSTRUCTION	XX11010011	"SHL %M0,CL"	%11100:regw
{
	DECLARE dummy[16];
	IF CL>=17
	{
		regw<-$0000;
		C<-0;
	}
	IF (CL>0) & (CL<17)
	{
		IF CL>1
		{
			DECLARE TMP[16];
			TMP<-CL-1;
			regw<-ROL(regw,dummy,$0000,TMP);
		}
		regw<-ROL(regw,C,$0000,1);
	}
	8+CL->CYCLES;
}

INSTRUCTION	"AND AX,#%$2%$1"	%00100101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AX & TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	XX00001011	"OR %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw | regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	XX11010011	"SHR %M0,CL"	%11101:regw
{
	DECLARE dummy[16];
	IF CL>=17
	{
		regw<-$0000;
		C<-0;
	}
	IF (CL>0) & (CL<17)
	{
		IF CL>1
		{
			DECLARE TMP[16];
			TMP<-CL-1;
			regw<-ROR(regw,dummy,$0000,TMP);
		}
		regw<-ROR(regw,C,$0000,1);
	}
	8+CL->CYCLES;
}

INSTRUCTION	"DEC %M0"	%01001:regw
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,$0001,15), P AS PARITYEVEN { regw - 1 }->regw;
	2->CYCLES;
}

INSTRUCTION	XX11110110	"NEG %M0"		%11011:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN, C AS CARRY(7) { 0 - regl }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10001010	"MOV %M0,%M1"	%11:regl:reglop2
{
	regl<-reglop2;
	2->CYCLES;
}

INSTRUCTION	XX11111110	"INC %M0"	%11000:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN { regl + 1 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10000011	"CMP %M0,#%$1"	%11111:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP };
	4->CYCLES;
}

INSTRUCTION	"STOSB"		%10101010
{
	CALL StoreByte(ES,DI,AL);
	IF D==0
	{
		DI<-DI+1;
	}
	IF D==1
	{
		DI<-DI-1;
	}
	11->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		8->CYCLES;
	}
}

INSTRUCTION	XX11111110	"DEC %M0"	%11001:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN { regl - 1 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX11111111	"DEC %M0"	%11001:regw
{
	DEBUG_TRACE "iksdfhoisdhfoisdhfoishdhfoisdhoifhsiodfhoisdhofhsdoifhosdihfosdhfoishdofihsdofihosidhfoisdhofihsdofihsodifhoisdhfoishfo";
	IP<-IP-2;
#	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN { regl + 1 }->regl;
#	3->CYCLES;
}

INSTRUCTION	"IN AL,#%$1"		%11100100,B2[8]
{
	CALL GetPortB(CALL GetImmediateByte())->AL;
	10->CYCLES;
}

INSTRUCTION	"IN AX,#%$1"		%11100101,B2[8]
{
	CALL GetPortW(CALL GetImmediateByte())->AX;
	10->CYCLES;
}

INSTRUCTION	XX11010001	"SHL %M0,#1"	%11100:regw
{
	DECLARE dummy[16];
	regw<-ROL(regw,C,$0000,1);
	O<-1;
	IF regw[15]==C
	{
		O<-0;
	}
	2->CYCLES;
}

INSTRUCTION	XX11010000	"SHR %M0,#1"	%11101:regl
{
	DECLARE dummy[8];
	O<-regl[7];
	regl<-ROR(regl,C,$00,1);
	2->CYCLES;
}

INSTRUCTION	XX11110110	"TEST %M0,#%$1"		%11000:regl,B2[8]
{
	DECLARE T[8];
	CALL GetImmediateByte()->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { regl & T };
	5->CYCLES;
}

INSTRUCTION	XX11010001	"SHR %M0,#1"	%11101:regw
{
	DECLARE dummy[16];
	O<-regw[15];
	regw<-ROR(regw,C,$0000,1);
	2->CYCLES;
}

INSTRUCTION	XX00000010	"ADD %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,reglop2,7), C AS CARRY(7), P AS PARITYEVEN { regl + reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10000000	"CMP %M0,#%$1"	%11111:regl,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl - TMP };
	4->CYCLES;
}

INSTRUCTION	"TEST AX,#%$2%$1"		%10101001,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { AX & T };
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	EAdisp<-CALL GetImmediateWord();
	9+8->CYCLES;
	CALL FetchWord(DS,EAdisp)->regw;
}

INSTRUCTION	XX10000011	"SUB %M0,#%$1"	%11101:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001100	"MOV %M1,%M0"	%110:regs:regw
{
	regw<-regs;
	2->CYCLES;
}

INSTRUCTION	"SUB AX,#%$2%$1"	%00101101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,TMP,15), C AS CARRY(15), P AS PARITYEVEN { AX - TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	"AND AL,#%$1"	%00100100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AL & TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX10001100	"MOV [%M1+#%$1],%M0"	%010:regs:memmod00,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod00+4+9->CYCLES;
	CALL StoreWord(DS,EA,regs);
}

INSTRUCTION	XX10001100	"MOV [#%$2%$1],%M0"		%000:regs:%110,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL StoreWord(DS,EAdisp,regs);
}

INSTRUCTION	"MOV AX,[%$2%$1]"	%10100001,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	10->CYCLES;
	CALL FetchWord(DS,T)->AX;
}

INSTRUCTION	"OR AL,#%$1"	%00001100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AL | TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX00110010	"XOR %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl ^ reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX00001010	"OR %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl | reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	"SUB AL,#%$1"	%00101100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AL,TMP,7), C AS CARRY(7), P AS PARITYEVEN { AL - TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	"ADD AX,#%$2%$1"	%00000101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,TMP,15), C AS CARRY(15), P AS PARITYEVEN { AX + TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	"ADD AL,#%$1"	%00000100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AL,TMP,7), C AS CARRY(7), P AS PARITYEVEN { AL + TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX10001010	"MOV %M0,[%M1]"	%00:regl:memmod00
{
	0->EAdisp;
	memmod00+8->CYCLES;
	CALL FetchByte(DS,EA)->regl;
}

INSTRUCTION	XX00111010	"CMP %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,reglop2,7), C AS CARRY(7), P AS PARITYEVEN { regl - reglop2 };
	3->CYCLES;
}

INSTRUCTION	XX00010011	"ADC %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { (regw + regwop2)+C }->regw;
	3->CYCLES;
}

INSTRUCTION	XX10000011	"ADC %M0,#%$1"	%11010:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { (regw + TMP)+C }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001001	"MOV [%M1+#%$1],%M0"		%01:regw:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL StoreWord(DS,EA,regw);
}

INSTRUCTION	XX10000011	"AND %M0,#%$1"	%11100:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX11000110 	"MOV [#%$2%$1],#%$3"	%00000110,B2[8],B3[8],B4[8]
{
	DECLARE T[8];
	EAdisp<-CALL GetImmediateWord();
	T<-CALL GetImmediateByte();
	9+10->CYCLES;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	"MOVSW"		%10100101
{
	DECLARE TMP[16];
	CALL FetchWord(DS,SI)->TMP;
	CALL StoreWord(ES,DI,TMP);
	IF D==0
	{
		SI<-SI+2;
		DI<-DI+2;
	}
	IF D==1
	{
		SI<-SI-2;
		DI<-DI-2;
	}
	18->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		15->CYCLES;
	}
}

INSTRUCTION	XX11111110	"INC [#%$2%$1]"	%00000:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+15->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	"MOV AL,[%$2%$1]"	%10100000,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	10->CYCLES;
	CALL FetchByte(DS,T)->AL;
}

INSTRUCTION	XX00111010	"CMP %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,T,7), C AS CARRY(7), P AS PARITYEVEN { regl - T };
}

INSTRUCTION	XX10001010	"MOV %M0,[%M1+#%$1]"	%01:regl:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+8->CYCLES;
	CALL FetchByte(DS,EA)->regl;
}

INSTRUCTION	XX11010010	"SHR %M0,CL"	%11101:regl
{
	DECLARE dummy[8];
	IF CL>=9
	{
		regl<-$00;
		C<-0;
	}
	IF (CL>0) & (CL<9)
	{
		IF CL>1
		{
			DECLARE TMP[8];
			TMP<-CL-1;
			regl<-ROR(regl,dummy,$00,TMP);
		}
		regl<-ROR(regl,C,$00,1);
	}
	8+CL->CYCLES;
}

INSTRUCTION	"JMP #%$2%$1"	%11101001,B2[8],B3[8]
{
	DECLARE disp[16];
	disp<-CALL GetImmediateWord();
	IP<-IP++disp;
	15->CYCLES;
}

INSTRUCTION	XX10000000	"CMP [#%$2%$1],#%$3"	%00111:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	9+10->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX00000011	"ADD %M0,[#%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
}

INSTRUCTION	XX10000011	"CMP [%M0],#%$1"	%00111:memmod00,B2[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	0->EAdisp;
	memmod00+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000011	"CMP [%M0+#%$1],#%$2"	%01111:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX00001001	"OR [#%$2%$1],%M0"	%00:regw:%110,B2[8],B2[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw | TMP }->TMP;
	CALL StoreWord(DS,EAdisp,TMP);
	9+16->CYCLES;
}

INSTRUCTION	XX10000011	"ADD [#%$2%$1],#%$3"	%00000:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T + TMP}->T;
	CALL StoreWord(DS,EAdisp,T);
	9+17->CYCLES;
}

INSTRUCTION	XX10000001	"CMP [#%$2%$1],#%$4%$3"	%00111:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+10->CYCLES;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000000	"AND [#%$2%$1],#%$3"	%00100:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	9+17->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { T & TMP }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	XX10001010	"MOV %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	9+8->CYCLES;
	CALL FetchByte(DS,EAdisp)->regl;
}

INSTRUCTION	XX00111010	"CMP %M0,[%M1+#%$2%$1]"	%10:regl:memmod,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,T,7), C AS CARRY(7), P AS PARITYEVEN { regl - T };
}

