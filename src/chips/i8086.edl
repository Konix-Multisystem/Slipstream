# intel 8086
#
# Simplified - Relatively quickly knocked together - cycle counts are wrong for word boundary misalignment!
#

C_FUNC_EXTERN	[8]	GetByte			[32];
# unsigned char GetByte(unsigned short);
#  Called when the cpu wants to read from memory
C_FUNC_EXTERN		SetByte			[32],[8];
# void SetByte(unsigned short,unsigned char);
#  Called when the cpu wants to write to memory
C_FUNC_EXTERN	[16]	GetPortW		[16];
# unsigned short GetPortW(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortW		[16],[16];
# void SetPortW(unsigned short,unsiged short);
#  Called when the cpu wants to write a word to an output port
C_FUNC_EXTERN	[8]	GetPortB		[16];
# unsigned short GetPortB(unsigned short);
#  Called when the cpu wants the value from a given port
C_FUNC_EXTERN		SetPortB		[16],[8];
# void SetPortB(unsigned short,unsiged short);
#  Called when the cpu wants to write a byte to an output port

DECLARE CYCLES[8];

# Programmer registers
DECLARE AX[16]	ALIAS	AH[8]:AL[8];
DECLARE BX[16]	ALIAS	BH[8]:BL[8];
DECLARE CX[16]	ALIAS	CH[8]:CL[8];
DECLARE	DX[16]	ALIAS	DH[8]:DL[8];

DECLARE	SP[16];
DECLARE	BP[16];
DECLARE	SI[16];
DECLARE	DI[16];

DECLARE	CS[16];
DECLARE	DS[16];
DECLARE	SS[16];
DECLARE	ES[16];

DECLARE	IP[16];

DECLARE	FLAGS[16]	ALIAS	%0000:O[1]:D[1]:I[1]:T[1]:S[1]:Z[1]:%0:A[1]:%0:P[1]:%0:C[1];		#

############

DECLARE INTERNAL REPEAT[1];
DECLARE INTERNAL EA[16];
DECLARE INTERNAL EAdisp[16];

DECLARE INTERNAL HALT[1];
DECLARE INTERNAL SegOveride[1];
DECLARE INTERNAL SegOverideValue[16];

DECLARE INTERNAL interruptPending[1];
DECLARE INTERNAL interruptVector[8];

DECLARE INTERNAL IRQBlock[1];

############

FUNCTION INTERNAL byte[8]	GetByteFromPhysicalAddress	segment[16],offset[16]
{
	DECLARE dummy[4];
	DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

	pageOffset<-segment;
	physical<-ROL(physical,dummy,%0000,4);
	physical<-physical+offset;
	byte<-CALL GetByte(physical);
}

FUNCTION INTERNAL	SetByteAtPhysicalAddress	segment[16],offset[16],byte[8]
{
	DECLARE dummy[4];
	DECLARE physical[24]	ALIAS	page[8]:pageOffset[16];

	pageOffset<-segment;
	physical<-ROL(physical,dummy,%0000,4);
	physical<-physical+offset;
	CALL SetByte(physical,byte);
}

FUNCTION INTERNAL	StoreWord	seg[16],off[16],wrd[16]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideValue,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(SegOverideValue,off+1,wrd[8..15]);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(seg,off,wrd[0..7]);
		CALL SetByteAtPhysicalAddress(seg,off+1,wrd[8..15]);
	}
}

FUNCTION INTERNAL	StoreByte	seg[16],off[16],byt[8]
{
	IF SegOveride
	{
		CALL SetByteAtPhysicalAddress(SegOverideValue,off,byt);
	}
	IF ~SegOveride
	{
		CALL SetByteAtPhysicalAddress(seg,off,byt);
	}
}

FUNCTION INTERNAL	wrd[16]		FetchWord		seg[16],off[16]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideValue,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(SegOverideValue,off+1)->wrd[8..15];
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(seg,off)->wrd[0..7];
		CALL GetByteFromPhysicalAddress(seg,off+1)->wrd[8..15];
	}
}

FUNCTION INTERNAL	byt[8]		FetchByte		seg[16],off[16]
{
	IF SegOveride
	{
		CALL GetByteFromPhysicalAddress(SegOverideValue,off)->byt;
	}
	IF ~SegOveride
	{
		CALL GetByteFromPhysicalAddress(seg,off)->byt;
	}
}

FUNCTION INTERNAL	PushWord	wrd[16]
{
	SP<-SP - 1;
	CALL SetByteAtPhysicalAddress(SS,SP,wrd[8..15]);
	SP<-SP - 1;
	CALL SetByteAtPhysicalAddress(SS,SP,wrd[0..7]);
}

FUNCTION INTERNAL	wrd[16]		PopWord
{
	CALL GetByteFromPhysicalAddress(SS,SP) -> wrd[0..7];
	SP<-SP + 1;
	CALL GetByteFromPhysicalAddress(SS,SP) -> wrd[8..15];
	SP<-SP + 1;
}

FUNCTION INTERNAL	byt[8]		GetImmediateByte
{
	CALL GetByteFromPhysicalAddress(CS,IP) -> byt;
	IP<-IP+1;
}

FUNCTION INTERNAL	wrd[16]		GetImmediateWord
{
	CALL GetImmediateByte() -> wrd[0..7];
	CALL GetImmediateByte() -> wrd[8..15];
}

############

FUNCTION STEP
{
	DECLARE	IR[8];

	SegOveride<-0;

	IRQBlock<-0;

	IF (~interruptPending) | REPEAT
	{
		IF ~HALT
		{
			IR<-CALL GetByteFromPhysicalAddress(CS,IP);
			IP<-IP+1;

			EXECUTE	IR;
		}
	}

	IF interruptPending & (~REPEAT)
	{
		HALT<-0;
		interruptPending<-0;
		# Standard interrupt procedure
		CALL PushWord(FLAGS);
		I<-0;
		CALL PushWord(CS);
		CALL PushWord(IP);
		DECLARE TMP[16];
		DECLARE dummy[2];
		TMP<-interruptVector;
		TMP<-ROL(TMP,dummy,%0000,2);
		CALL FetchWord($0000,TMP)->IP;
		CALL FetchWord($0000,TMP+2)->CS;

		61->CYCLES;
	}

}

FUNCTION INTERRUPT	vector[8]
{
	#Flag interrupt pending (if interrupts enabled or NMI) -- Interrupt will occur at next possible cpu step
	IF I & (~IRQBlock)
	{
		interruptPending<-1;
		interruptVector<-vector;
	}
}

FUNCTION RESET
{
	interruptPending<-0;
	IRQBlock<-0;
	REPEAT<-0;
	IP<-0;
	CS<-$FFFF;
	DS<-0;
	SS<-0;
	ES<-0;
	FLAGS<-0;
	HALT<-0;
}

############

MAPPING	flags[4]
{
	%1000	"CLC"	C<-0;
	%0101	"CMC"	C<-~C;
	%1001	"STC"	C<-1;
	%1010	"CLI"	I<-0;
	%1100	"CLD"	D<-0;
	%1101	"STD"	D<-1;
}

MAPPING	regl[3]
{
	%000	"AL"	AL;
	%001	"CL"	CL;
	%010	"DL"	DL;
	%011	"BL"	BL;
	%100	"AH"	AH;
	%101	"CH"	CH;
	%110	"DH"	DH;
	%111	"BH"	BH;
}

MAPPING	reglop2[3]
{
	%000	"AL"	AL;
	%001	"CL"	CL;
	%010	"DL"	DL;
	%011	"BL"	BL;
	%100	"AH"	AH;
	%101	"CH"	CH;
	%110	"DH"	DH;
	%111	"BH"	BH;
}

MAPPING	regw[3]
{
	%000	"AX"	AX;
	%001	"CX"	CX;
	%010	"DX"	DX;
	%011	"BX"	BX;
	%100	"SP"	SP;
	%101	"BP"	BP;
	%110	"SI"	SI;
	%111	"DI"	DI;
}

MAPPING	regwop2[3]
{
	%000	"AX"	AX;
	%001	"CX"	CX;
	%010	"DX"	DX;
	%011	"BX"	BX;
	%100	"SP"	SP;
	%101	"BP"	BP;
	%110	"SI"	SI;
	%111	"DI"	DI;
}

MAPPING regs[2]
{
	%00	"ES"	ES;
	%01	"CS"	CS;
	%10	"SS"	SS;
	%11	"DS"	DS;
}

INSTRUCTION	"XX001__110(Segment Overide %M0)"	%001:regs:%110
{
	DECLARE IR[8];
	SegOverideValue<-regs;
	SegOveride<-1;
	IR<-CALL GetImmediateByte();
	EXECUTE IR;
	2+CYCLES->CYCLES;
}

INSTRUCTION	"XX00000000"		%00000000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000000 IR;
}

INSTRUCTION	"XX00000001"		%00000001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000001 IR;
}

INSTRUCTION	"XX00000010"		%00000010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000010 IR;
}

INSTRUCTION	"XX00000011"		%00000011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00000011 IR;
}

INSTRUCTION	"XX00001000"		%00001000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001000 IR;
}

INSTRUCTION	"XX00001001"		%00001001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001001 IR;
}

INSTRUCTION	"XX00001010"		%00001010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001010 IR;
}

INSTRUCTION	"XX00001011"		%00001011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00001011 IR;
}

INSTRUCTION	"XX00010011"		%00010011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00010011 IR;
}

INSTRUCTION	"XX00100000"		%00100000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00100000 IR;
}

INSTRUCTION	"XX00100001"		%00100001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00100001 IR;
}

INSTRUCTION	"XX00100010"		%00100010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00100010 IR;
}

INSTRUCTION	"XX00100011"		%00100011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00100011 IR;
}

INSTRUCTION	"XX00101000"		%00101000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00101000 IR;
}

INSTRUCTION	"XX00101001"		%00101001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00101001 IR;
}

INSTRUCTION	"XX00101010"		%00101010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00101010 IR;
}

INSTRUCTION	"XX00101011"		%00101011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00101011 IR;
}

INSTRUCTION	"XX00110000"		%00110000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110000 IR;
}

INSTRUCTION	"XX00110001"		%00110001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110001 IR;
}

INSTRUCTION	"XX00110010"		%00110010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110010 IR;
}

INSTRUCTION	"XX00110011"		%00110011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00110011 IR;
}

INSTRUCTION	"XX00111000"		%00111000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111000 IR;
}

INSTRUCTION	"XX00111001"		%00111001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111001 IR;
}

INSTRUCTION	"XX00111010"		%00111010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111010 IR;
}

INSTRUCTION	"XX00111011"		%00111011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX00111011 IR;
}


INSTRUCTION	"XX10000000"		%10000000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000000 IR;
}

INSTRUCTION	"XX10000001"		%10000001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000001 IR;
}

INSTRUCTION	"XX10000011"		%10000011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000011 IR;
}

INSTRUCTION	"XX10000110"		%10000110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000110 IR;
}

INSTRUCTION	"XX10000111"		%10000111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10000111 IR;
}

INSTRUCTION	"XX10001000"		%10001000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001000 IR;
}

INSTRUCTION	"XX10001001"		%10001001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001001 IR;
}

INSTRUCTION	"XX10001010"		%10001010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001010 IR;
}

INSTRUCTION	"XX10001011"		%10001011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001011 IR;
}

INSTRUCTION	"XX10001100"		%10001100
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001100 IR;
}

INSTRUCTION	"XX10001101"		%10001101
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001101 IR;
}

INSTRUCTION	"XX10001110"		%10001110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001110 IR;
}

INSTRUCTION	"XX10001111"		%10001111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX10001111 IR;
}

INSTRUCTION	"XX11000110"		%11000110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11000110 IR;
}

INSTRUCTION	"XX11000111"		%11000111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11000111 IR;
}

INSTRUCTION	"XX11010000"		%11010000
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010000 IR;
}

INSTRUCTION	"XX11010001"		%11010001
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010001 IR;
}

INSTRUCTION	"XX11010010"		%11010010
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010010 IR;
}

INSTRUCTION	"XX11010011"		%11010011
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11010011 IR;
}

INSTRUCTION	"XX11110110"		%11110110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11110110 IR;
}

INSTRUCTION	"XX11110111"		%11110111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11110111 IR;
}

INSTRUCTION	"XX11111110"		%11111110
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11111110 IR;
}

INSTRUCTION	"XX11111111"		%11111111
{
	DECLARE IR[8];
	IR<-CALL GetImmediateByte();
	EXECUTE XX11111111 IR;
}


######

INSTRUCTION	"%M0"	%1111:flags
{
	flags;
	2->CYCLES;
}

INSTRUCTION	"STI"	%11111011
{
	I<-1;
	IRQBlock<-1;
	2->CYCLES;
}

INSTRUCTION	"MOV %M0,#%$2%$1"	%10111:regw,B2[8],B3[8]
{
	regw<-CALL GetImmediateWord();
	4->CYCLES;
}

INSTRUCTION	XX10001110	"MOV %M0,%M1"	%110:regs:regw
{
	regs<-regw;
	2->CYCLES;
}

INSTRUCTION	"OUT #%$1,AL"		%11100110,B2[8]
{
	CALL SetPortB(CALL GetImmediateByte(),AL);
	10->CYCLES;
}

INSTRUCTION	"OUT #%$1,AX"		%11100111,B2[8]
{
	CALL SetPortW(CALL GetImmediateByte(),AX);
	10->CYCLES;
}

INSTRUCTION	XX00110011	"XOR %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw ^ regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	"INC %M0"	%01000:regw
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,$0001,15), P AS PARITYEVEN { regw + 1 }->regw;
	2->CYCLES;
}

INSTRUCTION	"MOV %M0,#%$1"	%10110:regl,B2[8]
{
	regl<-CALL GetImmediateByte();
	4->CYCLES;
}

INSTRUCTION	"CALL #%$2%$1"	%11101000,B2[8],B3[8]
{
	DECLARE disp[16];
	disp<-CALL GetImmediateWord();
	CALL PushWord(IP);
	IP<-IP ++ disp;
	19->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,%M1"	%11:regw:regwop2
{
	regw<-regwop2;
	2->CYCLES;
}

INSTRUCTION	"XCHG AX,%M0"	%10010:regw
{
	AX<->regw;
	3->CYCLES;
}

INSTRUCTION	"STOSW"		%10101011
{
	CALL StoreWord(ES,DI,AX);
	IF D==0
	{
		DI<-DI+2;
	}
	IF D==1
	{
		DI<-DI-2;
	}
	11->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		8->CYCLES;
	}
}

INSTRUCTION	"LOOP #%$1"		%11100010,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	CX<-CX-1;
	5->CYCLES;
	IF CX!=0
	{
		IP<-IP++disp;
		17->CYCLES;
	}
}

INSTRUCTION	"RET"		%11000011
{
	IP<-CALL PopWord();
	8->CYCLES;
}

INSTRUCTION	"REP(E)"	%11110011			# interrupts must not fire on this prefix code
{
	IF CX==0
	{
		9->CYCLES;
		IP <- IP + 1;
	}
	IF CX!=0
	{
		REPEAT<-1;
		CX<-CX - 1;
		2->CYCLES;
	}
}

INSTRUCTION	"JMP #%$1"	%11101011,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	IP<-IP++disp;
	15->CYCLES;
}

FUNCTION INTERNAL	cyc[8]	CalculateEA	code[3],disp[16]
{
	IF code==%000
	{
		cyc<-7;
		EA<-BX+SI+disp;
	}
	IF code==%001
	{
		cyc<-8;
		EA<-BX+DI+disp;
	}
	IF code==%010
	{
		cyc<-8;
		EA<-BP+SI+disp;
	}
	IF code==%011
	{
		cyc<-7;
		EA<-BP+DI+disp;
	}
	IF code==%100
	{
		cyc<-5;
		EA<-SI+disp;
	}
	IF code==%101
	{
		cyc<-5;
		EA<-DI+disp;
	}
	IF code==%110
	{
		cyc<-5;
		EA<-BP+disp;
	}
	IF code==%111
	{
		cyc<-5;
		EA<-BX+disp;
	}
}

MAPPING memmod[3]
{
	%000	"BX+SI"	CALL CalculateEA(%000,EAdisp);
	%001	"BX+DI"	CALL CalculateEA(%001,EAdisp);
	%010	"BP+SI"	CALL CalculateEA(%010,EAdisp);
	%011	"BP+DI"	CALL CalculateEA(%011,EAdisp);
	%100	"SI"	CALL CalculateEA(%100,EAdisp);
	%101	"DI"	CALL CalculateEA(%101,EAdisp);
	%110	"BP"	CALL CalculateEA(%110,EAdisp);
	%111	"BX"	CALL CalculateEA(%111,EAdisp);
}

MAPPING memmod00[3]
{
	%000	"BX+SI"	CALL CalculateEA(%000,EAdisp);
	%001	"BX+DI"	CALL CalculateEA(%001,EAdisp);
	%010	"BP+SI"	CALL CalculateEA(%010,EAdisp);
	%011	"BP+DI"	CALL CalculateEA(%011,EAdisp);
	%100	"SI"	CALL CalculateEA(%100,EAdisp);
	%101	"DI"	CALL CalculateEA(%101,EAdisp);
#	%110	"BP"	CALL CalculateEA(%110;
	%111	"BX"	CALL CalculateEA(%111,EAdisp);
}

INSTRUCTION	XX11000111 	"MOV [%M0],#%$2%$1"	%00000:memmod00,B2[8],B3[8]
{
	DECLARE T[16];
	T<-CALL GetImmediateWord();
	0->EAdisp;
	memmod00+10->CYCLES;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11000111 	"MOV [#%$2%$1],#%$4%$3"	%00000110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	T<-CALL GetImmediateWord();
	9+10->CYCLES;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX11000111 	"MOV [%M0+#%$1],#%$3%$2"	%01000:memmod00,B2[8],B3[8],B4[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	T<-CALL GetImmediateWord();
	memmod00+4+10->CYCLES;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10000011	"ADD %M0,#%$1"	%11000:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%M1]"	%00:regw:memmod00
{
	0->EAdisp;
	memmod00+8->CYCLES;
	CALL FetchWord(DS,EA)->regw;
}

INSTRUCTION	XX00000011	"ADD %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { regw + regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	XX10000001	"ADD %M0,#%$2%$1"	%11000:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%M1+#%$1]"	%01:regw:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+8->CYCLES;
	CALL FetchWord(DS,EA)->regw;
}

INSTRUCTION	"LODSW"		%10101101
{
	CALL FetchWord(DS,SI)->AX;
	IF D==0
	{
		SI<-SI+2;
	}
	IF D==1
	{
		SI<-SI-2;
	}
	12->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		9->CYCLES;
	}
}

INSTRUCTION	XX00111011	"CMP %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { regw - regwop2 };
	3->CYCLES;
}

MAPPING cond[4]
{
	%0100	"E"	Z;
	%1100	"L"	S!=O;
	%1110	"LE"	Z | (S!=O);
	%0010	"C"	C;
	%0110	"BE"	C | Z;
	%1010	"P"	P;
	%0000	"O"	O;
	%1000	"S"	S;
	%0101	"NE"	~Z;
	%1101	"GE"	S==O;
	%1111	"G"	(~Z) & (S==O);
	%0011	"AE"	~C;
	%0111	"A"	(~C) & (~Z);
	%1011	"PO"	~P;
	%0001	"NO"	~O;
	%1001	"NS"	~S;
}

INSTRUCTION	"J%M0 %$1"	%0111:cond,B2[8]
{
	DECLARE disp[8];
	disp<-CALL GetImmediateByte();
	4->CYCLES;
	IF cond
	{
		IP<-IP++disp;
		16->CYCLES;
	}
}

INSTRUCTION	XX10001001	"MOV [%M1],%M0"		%00:regw:memmod00
{
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL StoreWord(DS,EA,regw);
}

INSTRUCTION	XX10001001	"MOV [#%$2%$1],%M0"		%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	9+9->CYCLES;
	CALL StoreWord(DS,EAdisp,regw);
}

INSTRUCTION	"MOV [%$2%$1],AX"		%10100011,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	CALL StoreWord(DS,T,AX);
	10->CYCLES;
}

INSTRUCTION	"PUSH %M0"	%01010:regw
{
	CALL PushWord(regw);
	11->CYCLES;
}

INSTRUCTION	"PUSH %M0"	%000:regs:%110
{
	CALL PushWord(regs);
	10->CYCLES;
}

INSTRUCTION	"CMP AX,#%$2%$1"	%00111101,B2[8],B3[8]
{
	DECLARE T[16];
	T<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,T,15), C AS CARRY(15), P AS PARITYEVEN { AX - T };
	4->CYCLES;
}

INSTRUCTION	"CMP AL,#%$1"	%00111100,B2[8]
{
	DECLARE T[8];
	T<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,T,7), C AS CARRY(7), P AS PARITYEVEN { AL - T };
	4->CYCLES;
}

INSTRUCTION	XX10000110	"XCHG %M0,%M1"		%11:regl:reglop2
{
	regl<->reglop2;
	4->CYCLES;
}

INSTRUCTION	XX10000000	"CMP [%M0],#%$1"	%00111:memmod00,B2[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	TMP<-CALL GetImmediateByte();
	0->EAdisp;
	memmod00+10->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000001	"CMP %M0,#%$2%$1"	%11111:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP };
	4->CYCLES;
}

INSTRUCTION	XX10000011	"CMP [#%$2%$1],#%$3"	%00111:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	9+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	"POP %M0"	%01011:regw
{
	CALL PopWord()->regw;
	8->CYCLES;
}

INSTRUCTION	"POP %M0"	%000:regs:%111
{
	CALL PopWord()->regs;
	8->CYCLES;
}

INSTRUCTION	"IRET"		%11001111
{
	IP<-CALL PopWord();
	CS<-CALL PopWord();
	FLAGS<-CALL PopWord();
	24->CYCLES;
}

INSTRUCTION	"LODSB"		%10101100
{
	CALL FetchByte(DS,SI)->AL;
	IF D==0
	{
		SI<-SI+1;
	}
	IF D==1
	{
		SI<-SI-1;
	}
	12->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		9->CYCLES;
	}
}

INSTRUCTION	XX11010011	"SHL %M0,CL"	%11100:regw
{
	DECLARE dummy[16];
	DECLARE shCnt[5];

	shCnt<-CL;
	IF shCnt>=17
	{
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN,C AS FORCERESET { $0000 }->regw;
	}
	IF (shCnt>0) & (shCnt<17)
	{
		IF shCnt>1
		{
			shCnt<-shCnt-1;
			regw<-ROL(regw,dummy,$0000,shCnt);
		}

		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROL(regw,C,$0000,1) }->regw;
	}
	8+((CL[0..4])*$04)->CYCLES;
}

INSTRUCTION	"AND AX,#%$2%$1"	%00100101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AX & TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	XX00001011	"OR %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw | regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	XX11010011	"SHR %M0,CL"	%11101:regw
{
	DECLARE dummy[16];
	DECLARE shCnt[5];

	shCnt<-CL;
	IF shCnt>=17
	{
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN,C AS FORCERESET { $0000 }->regw;
	}
	IF (shCnt>0) & (shCnt<17)
	{
		IF shCnt>1
		{
			shCnt<-shCnt-1;
			regw<-ROR(regw,dummy,$0000,shCnt);
		}
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regw,C,$0000,1) }->regw;
	}
	8+((CL[0..4])*$04)->CYCLES;
}

INSTRUCTION	"DEC %M0"	%01001:regw
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,$0001,15), P AS PARITYEVEN { regw - 1 }->regw;
	2->CYCLES;
}

INSTRUCTION	XX11110110	"NEG %M0"		%11011:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($00,regl,7), P AS PARITYEVEN, C AS CARRY(7) { 0 - regl }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10001010	"MOV %M0,%M1"	%11:regl:reglop2
{
	regl<-reglop2;
	2->CYCLES;
}

INSTRUCTION	XX11111110	"INC %M0"	%11000:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN { regl + 1 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10000011	"CMP %M0,#%$1"	%11111:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP };
	4->CYCLES;
}

INSTRUCTION	"STOSB"		%10101010
{
	CALL StoreByte(ES,DI,AL);
	IF D==0
	{
		DI<-DI+1;
	}
	IF D==1
	{
		DI<-DI-1;
	}
	11->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		8->CYCLES;
	}
}

INSTRUCTION	XX11111110	"DEC %M0"	%11001:regl
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,$01,7), P AS PARITYEVEN { regl - 1 }->regl;
	3->CYCLES;
}

INSTRUCTION	"IN AL,#%$1"		%11100100,B2[8]
{
	CALL GetPortB(CALL GetImmediateByte())->AL;
	10->CYCLES;
}

INSTRUCTION	"IN AX,#%$1"		%11100101,B2[8]
{
	CALL GetPortW(CALL GetImmediateByte())->AX;
	10->CYCLES;
}

INSTRUCTION	XX11010001	"SHL %M0,#1"	%11100:regw
{
	DECLARE dummy[16];
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROL(regw,C,$0000,1) }->regw;
	O<-1;
	IF regw[15..15]==C
	{
		O<-0;
	}
	2->CYCLES;
}

INSTRUCTION	XX11010000	"SHR %M0,#1"	%11101:regl
{
	DECLARE dummy[8];
	O<-regl[7];
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regl,C,$00,1) }->regl;
	2->CYCLES;
}

INSTRUCTION	XX11110110	"TEST %M0,#%$1"		%11000:regl,B2[8]
{
	DECLARE T[8];
	CALL GetImmediateByte()->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { regl & T };
	5->CYCLES;
}

INSTRUCTION	XX11010001	"SHR %M0,#1"	%11101:regw
{
	DECLARE dummy[16];
	O<-regw[15];
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regw,C,$0000,1) }->regw;
	2->CYCLES;
}

INSTRUCTION	XX00000010	"ADD %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,reglop2,7), C AS CARRY(7), P AS PARITYEVEN { regl + reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX10000000	"CMP %M0,#%$1"	%11111:regl,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl - TMP };
	4->CYCLES;
}

INSTRUCTION	"TEST AX,#%$2%$1"		%10101001,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { AX & T };
	4->CYCLES;
}

INSTRUCTION	XX10001011	"MOV %M0,[%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	EAdisp<-CALL GetImmediateWord();
	9+8->CYCLES;
	CALL FetchWord(DS,EAdisp)->regw;
}

INSTRUCTION	XX10000011	"SUB %M0,#%$1"	%11101:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001100	"MOV %M1,%M0"	%110:regs:regw
{
	regw<-regs;
	2->CYCLES;
}

INSTRUCTION	"SUB AX,#%$2%$1"	%00101101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,TMP,15), C AS CARRY(15), P AS PARITYEVEN { AX - TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	"AND AL,#%$1"	%00100100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AL & TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX10001100	"MOV [%M1+#%$1],%M0"	%010:regs:memmod00,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod00+4+9->CYCLES;
	CALL StoreWord(DS,EA,regs);
}

INSTRUCTION	XX10001100	"MOV [#%$2%$1],%M0"		%000:regs:%110,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL StoreWord(DS,EAdisp,regs);
}

INSTRUCTION	"MOV AX,[%$2%$1]"	%10100001,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	10->CYCLES;
	CALL FetchWord(DS,T)->AX;
}

INSTRUCTION	"OR AL,#%$1"	%00001100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AL | TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX00110010	"XOR %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl ^ reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	XX00001010	"OR %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl | reglop2 }->regl;
	3->CYCLES;
}

INSTRUCTION	"SUB AL,#%$1"	%00101100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AL,TMP,7), C AS CARRY(7), P AS PARITYEVEN { AL - TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	"ADD AX,#%$2%$1"	%00000101,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AX,TMP,15), C AS CARRY(15), P AS PARITYEVEN { AX + TMP }->AX;
	4->CYCLES;
}

INSTRUCTION	"ADD AL,#%$1"	%00000100,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(AL,TMP,7), C AS CARRY(7), P AS PARITYEVEN { AL + TMP }->AL;
	4->CYCLES;
}

INSTRUCTION	XX10001010	"MOV %M0,[%M1]"	%00:regl:memmod00
{
	0->EAdisp;
	memmod00+8->CYCLES;
	CALL FetchByte(DS,EA)->regl;
}

INSTRUCTION	XX00111010	"CMP %M0,%M1"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,reglop2,7), C AS CARRY(7), P AS PARITYEVEN { regl - reglop2 };
	3->CYCLES;
}

INSTRUCTION	XX00010011	"ADC %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { (regw + regwop2)+C }->regw;
	3->CYCLES;
}

INSTRUCTION	XX10000011	"ADC %M0,#%$1"	%11010:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { (regw + TMP)+C }->regw;
	4->CYCLES;
}

INSTRUCTION	XX10001001	"MOV [%M1+#%$1],%M0"		%01:regw:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL StoreWord(DS,EA,regw);
}

INSTRUCTION	XX10000011	"AND %M0,#%$1"	%11100:regw,B2[8]
{
	DECLARE TMP[16];
	TMP<-$0000 ++ CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX11000110 	"MOV [#%$2%$1],#%$3"	%00000110,B2[8],B3[8],B4[8]
{
	DECLARE T[8];
	EAdisp<-CALL GetImmediateWord();
	T<-CALL GetImmediateByte();
	9+10->CYCLES;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	"MOVSW"		%10100101
{
	DECLARE TMP[16];
	CALL FetchWord(DS,SI)->TMP;
	CALL StoreWord(ES,DI,TMP);
	IF D==0
	{
		SI<-SI+2;
		DI<-DI+2;
	}
	IF D==1
	{
		SI<-SI-2;
		DI<-DI-2;
	}
	18->CYCLES;
	IF REPEAT
	{
		REPEAT<-0;
		IP<-IP - 2;
		15->CYCLES;
	}
}

INSTRUCTION	XX11111110	"INC [#%$2%$1]"	%00000:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+15->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	"MOV AL,[%$2%$1]"	%10100000,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	10->CYCLES;
	CALL FetchByte(DS,T)->AL;
}

INSTRUCTION	XX00111010	"CMP %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,T,7), C AS CARRY(7), P AS PARITYEVEN { regl - T };
}

INSTRUCTION	XX10001010	"MOV %M0,[%M1+#%$1]"	%01:regl:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+8->CYCLES;
	CALL FetchByte(DS,EA)->regl;
}

INSTRUCTION	XX11010010	"SHR %M0,CL"	%11101:regl
{
	DECLARE dummy[8];
	DECLARE shCnt[5];

	shCnt<-CL;
	IF shCnt>=9
	{
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN,C AS FORCERESET { $00 }->regl;
	}
	IF (shCnt>0) & (shCnt<9)
	{
		IF shCnt>1
		{
			shCnt<-shCnt-1;
			regl<-ROR(regl,dummy,$00,shCnt);
		}
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regl,C,$00,1) }->regl;
	}
	8+((CL[0..4])*$04)->CYCLES;
}

INSTRUCTION	"JMP #%$2%$1"	%11101001,B2[8],B3[8]
{
	DECLARE disp[16];
	disp<-CALL GetImmediateWord();
	IP<-IP++disp;
	15->CYCLES;
}

INSTRUCTION	XX10000000	"CMP [#%$2%$1],#%$3"	%00111:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	9+10->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX00000011	"ADD %M0,[#%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
}

INSTRUCTION	XX10000011	"CMP [%M0],#%$1"	%00111:memmod00,B2[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	0->EAdisp;
	memmod00+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000011	"CMP [%M0+#%$1],#%$2"	%01111:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+10->CYCLES;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX00001001	"OR [#%$2%$1],%M0"	%00:regw:%110,B2[8],B2[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw | TMP }->TMP;
	CALL StoreWord(DS,EAdisp,TMP);
	9+16->CYCLES;
}

INSTRUCTION	XX10000011	"ADD [#%$2%$1],#%$3"	%00000:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	TMP<-$0000 ++ CALL GetImmediateByte();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T + TMP}->T;
	CALL StoreWord(DS,EAdisp,T);
	9+17->CYCLES;
}

INSTRUCTION	XX10000001	"CMP [#%$2%$1],#%$4%$3"	%00111:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+10->CYCLES;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10000000	"AND [#%$2%$1],#%$3"	%00100:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	9+17->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { T & TMP }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	XX10001010	"MOV %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	9+8->CYCLES;
	CALL FetchByte(DS,EAdisp)->regl;
}

INSTRUCTION	XX00111010	"CMP %M0,[%M1+#%$2%$1]"	%10:regl:memmod,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,T,7), C AS CARRY(7), P AS PARITYEVEN { regl - T };
}

INSTRUCTION	XX11110110	"MUL %M0"		%11100:regl
{
	DECLARE lhs[16];
	DECLARE rhs[16];
	lhs<-AL;
	rhs<-regl;
	AX<-lhs * rhs;
	C<-AH!=$00;
	O<-C;

	70->CYCLES;								# 70 - 77 cycles
}

INSTRUCTION	XX10001000	"MOV [%M1+#%$1],%M0"		%01:regl:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL StoreByte(DS,EA,regl);
}

INSTRUCTION	"MOV [%$2%$1],AL"		%10100010,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->T;
	CALL StoreByte(DS,T,AL);
	10->CYCLES;
}

INSTRUCTION	XX10000001	"AND %M0,#%$2%$1"		%11100:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX00111011	"CMP %M0,[%M1]"	%00:regw:memmod00
{
	DECLARE T[16];
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,T,15), C AS CARRY(15), P AS PARITYEVEN { regw - T };
}

INSTRUCTION	XX11110111	"NOT %M0"		%11010:regw
{
	regw<-~regw;
	3->CYCLES;
}

INSTRUCTION	XX00100001	"AND [#%$2%$1],%M0"		%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+16->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & TMP }->TMP;
	CALL StoreWord(DS,EAdisp,TMP);
}

INSTRUCTION	"TEST AL,#%$1"		%10101000,B2[8]
{
	DECLARE T[8];
	CALL GetImmediateByte()->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { AX & T };
	4->CYCLES;
}

INSTRUCTION	XX11000110 	"MOV [%M0+#%$1],#%$2"	%01000:memmod,B2[8],B3[8]
{
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	T<-CALL GetImmediateByte();
	memmod+4+10->CYCLES;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX11110110	"DIV %M0"		%11110:regl
{
	DECLARE lhs[16];
	DECLARE rhs[16];
	lhs<-AX;
	rhs<-regl;
	AL<-lhs / rhs;
	AH<-lhs % rhs;
										# flags are undefined, leaving as they are for now
	101->CYCLES;								# 101 - 112 cycles
}

INSTRUCTION	XX11110111	"DIV %M0"		%11110:regw
{
	DECLARE lhs[32];
	DECLARE rhs[32];
	DX->lhs[16..31];
	AX->lhs[0..15];
	rhs<-regw;
	AX<-lhs / rhs;
	DX<-lhs % rhs;
										# flags are undefined, leaving as they are for now
	144->CYCLES;								# 144 - 162 cycles
}

INSTRUCTION	XX10000000	"AND %M0,#%$1"		%11100:regl,B2[8]
{
	DECLARE TMP[8];
	CALL GetImmediateByte()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl & TMP }->regl;
	4->CYCLES;
}

INSTRUCTION	XX00101011	"SUB %M0,%M1"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,regwop2,15), C AS CARRY(15), P AS PARITYEVEN { regw - regwop2 }->regw;
	3->CYCLES;
}

INSTRUCTION	XX00100010	"AND %M0,[#%$2%$1]"		%00:regl:%110,B2[8],B3[8]
{
	DECLARE TMP[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl & TMP }->regl;
}

INSTRUCTION	XX00000001	"ADD [%M1+#%$1],%M0"	%01:regw:memmod,B2[8]
{
	DECLARE TMP[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP + regw }->TMP;
	CALL StoreWord(DS,EA,TMP);
}

INSTRUCTION	XX00101000	"SUB [%M1+#%$1],%M0"	%01:regl:memmod,B2[8]
{
	DECLARE TMP[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regl,7), C AS CARRY(7), P AS PARITYEVEN { TMP - regl }->TMP;
	CALL StoreByte(DS,EA,TMP);
}

INSTRUCTION	XX00000000	"ADD [%M1+#%$1],%M0"	%01:regl:memmod,B2[8]
{
	DECLARE TMP[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regl,7), C AS CARRY(7), P AS PARITYEVEN { TMP + regl }->TMP;
	CALL StoreByte(DS,EA,TMP);
}

INSTRUCTION	XX10000000	"CMP [%M0+#%$1],#%$2"	%01111:memmod,B2[8],B3[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	TMP<-CALL GetImmediateByte();
	memmod+4+10->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	"CALL #%$4%$3:%$2%$1"	%10011010,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE offset[16];
	DECLARE segment[16];
	offset<-CALL GetImmediateWord();
	segment<-CALL GetImmediateWord();
	CALL PushWord(CS);
	CALL PushWord(IP);
	CS<-segment;
	IP<-offset;
	28->CYCLES;
}

INSTRUCTION	"RET"		%11001011
{
	IP<-CALL PopWord();
	CS<-CALL PopWord();
	18->CYCLES;
}

INSTRUCTION	XX00111011	"CMP %M0,[#%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,T,15), C AS CARRY(15), P AS PARITYEVEN { regw - T };
}

INSTRUCTION	"INT #%$1"	%11001101,B2[8]
{
	DECLARE TMP[16];
	DECLARE dummy[2];

	TMP<-CALL GetImmediateByte();
	CALL PushWord(FLAGS);
	I<-0;
	CALL PushWord(CS);
	CALL PushWord(IP);
	TMP<-ROL(TMP,dummy,%0000,2);
	CALL FetchWord($0000,TMP)->IP;
	CALL FetchWord($0000,TMP+2)->CS;

	51->CYCLES;
}

#INSTRUCTION	"MOVSB"		%10100100
#{
#	DECLARE TMP[8];
#	CALL FetchByte(DS,SI)->TMP;
#	CALL StoreByte(ES,DI,TMP);
#	IF D==0
#	{
#		SI<-SI+1;
#		DI<-DI+1;
#	}
#	IF D==1
#	{
#		SI<-SI-1;
#		DI<-DI-1;
#	}
#	18->CYCLES;
#	IF REPEAT
#	{
#		REPEAT<-0;
#		IP<-IP - 2;
#		15->CYCLES;
#	}
#}

INSTRUCTION	XX10000000	"XOR [#%$2%$1],#%$3"		%00110:%110,B2[8],B3[8],B4[8]
{
	DECLARE T[8];
	DECLARE TMP[8];
	EAdisp<-CALL GetImmediateWord();
	9+17->CYCLES;
	CALL GetImmediateByte()->TMP;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { T ^ TMP }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	"XOR AL,#%$1"		%00110100,B2[8]
{
	DECLARE T[8];
	CALL GetImmediateByte()->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { AL ^ T }->AL;
	4->CYCLES;
}

INSTRUCTION	XX10000000	"OR %M0,#%$1"		%11001:regl,B2[8]
{
	DECLARE TMP[8];
	CALL GetImmediateByte()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl | TMP }->regl;
	4->CYCLES;
}

INSTRUCTION	XX10001000	"MOV [#%$2%$1],%M0"		%00:regl:%110,B2[8],B3[8]
{
	EAdisp<-CALL GetImmediateWord();
	9+9->CYCLES;
	CALL StoreByte(DS,EAdisp,regl);
}

INSTRUCTION	XX11010000	"RCR %M0,#1"	%11011:regl
{
	regl<-ROR(regl,C,C,1);
	O<-regl[7..7]^regl[6..6];
	2->CYCLES;
}

INSTRUCTION	XX11010001	"RCR %M0,#1"	%11011:regw
{
	regw<-ROR(regw,C,C,1);
	O<-regw[15..15]^regw[14..14];
	2->CYCLES;
}

INSTRUCTION	XX11111111	"JMP [%M0]"	%00100:memmod00
{
	DECLARE disp[8];
	0->EAdisp;
	memmod00+18->CYCLES;
	CALL FetchWord(DS,EA)->IP;
}

INSTRUCTION	XX11111110	"DEC [#%$2%$1]"	%00001:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+15->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	XX11111111	"INC [#%$2%$1]"	%00000:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+15->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX00110001	"XOR %M1,%M0"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regwop2 ^ regw }->regwop2;
	3->CYCLES;
}

INSTRUCTION	XX00110000	"XOR %M1,%M0"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { reglop2 ^ regl }->reglop2;
	3->CYCLES;
}

INSTRUCTION	XX10001000	"MOV %M1,%M0"	%11:regl:reglop2
{
	reglop2<-regl;
	2->CYCLES;
}

INSTRUCTION	XX11010000	"SHL %M0,#1"	%11100:regl
{
	DECLARE dummy[8];
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROL(regl,C,$00,1) }->regl;
	O<-1;
	IF regl[7..7]==C
	{
		O<-0;
	}
	2->CYCLES;
}

INSTRUCTION	XX00001000	"OR %M1,%M0"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { reglop2 | regl }->reglop2;
	3->CYCLES;
}

INSTRUCTION	XX10001000	"MOV [%M1],%M0"		%00:regl:memmod00,B2[8]
{
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL StoreByte(DS,EA,regl);
}

INSTRUCTION	XX00100000	"AND %M1,%M0"		%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { reglop2 & regl }->reglop2;
	3->CYCLES;
}

INSTRUCTION	"JMP #%$4%$2:%$2%$1"	%11101010,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE off[16];
	DECLARE seg[16];
	off<-CALL GetImmediateWord();
	seg<-CALL GetImmediateWord();
	IP<-off;
	CS<-seg;
	15->CYCLES;
}

INSTRUCTION	XX10001001	"MOV [%M1+#%$2%$1],%M0"		%10:regw:memmod,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL StoreWord(DS,EA,regw);
}

INSTRUCTION	XX10001000	"MOV [%M1+#%$2%$1],%M0"		%10:regl:memmod,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL StoreByte(DS,EA,regl);
}

INSTRUCTION	XX00000011	"ADD %M0,[%M1]"			%00:regw:memmod00
{
	DECLARE TMP[16];
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
}

INSTRUCTION	XX10001001	"MOV %M1,%M0"	%11:regw:regwop2
{
	regwop2<-regw;
	2->CYCLES;
}

INSTRUCTION	XX10000001	"XOR %M0,#%$2%$1"		%11110:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw ^ TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	"HLT"		%11110100
{
	HALT<-1;
	2->CYCLES;
}

INSTRUCTION	XX10000000	"ADD %M0,#%$1"	%11000:regl,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl + TMP }->regl;
	4->CYCLES;
}

INSTRUCTION	XX00000001	"ADD %M1,%M0"		%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regwop2,regw,15), C AS CARRY(15), P AS PARITYEVEN { regwop2 + regw }->regwop2;
	3->CYCLES;
}

INSTRUCTION	XX10000000	"SUB %M0,#%$1"	%11101:regl,B2[8]
{
	DECLARE TMP[8];
	TMP<-CALL GetImmediateByte();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl - TMP }->regl;
	4->CYCLES;
}

INSTRUCTION	XX00101010	"SUB %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	DECLARE TMP[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl - TMP }->regl;
}

INSTRUCTION	XX10001011	"MOV %M0,[%M1+#%$2%$1]"	%10:regw:memmod,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	memmod+4+8->CYCLES;
	CALL FetchWord(DS,EA)->regw;
}

INSTRUCTION	XX00111001	"CMP %M1,%M0"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regwop2,regw,15), C AS CARRY(15), P AS PARITYEVEN { regwop2 - regw };
	3->CYCLES;
}

INSTRUCTION	XX00101001	"SUB %M1,%M0"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regwop2,regw,15), C AS CARRY(15), P AS PARITYEVEN { regwop2 - regw }->regwop2;
	3->CYCLES;
}

INSTRUCTION	XX10000001	"SUB %M0,#%$2%$1"	%11101:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX11110111	"NEG %M0"		%11011:regw
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($0000,regw,15), P AS PARITYEVEN, C AS CARRY(15) { 0 - regw }->regw;
	3->CYCLES;
}

INSTRUCTION	XX10000001	"ADD [#%$2%$1],#%$4%$3"	%00000:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateWord();
	9+17->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T + TMP }->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX10001100	"MOV [%M1],%M0"		%000:regs:memmod00
{
	0->EAdisp;
	memmod00+9->CYCLES;
	CALL StoreWord(DS,EA,regs);
}

INSTRUCTION	"PUSHF"		%10011100
{
	CALL PushWord(FLAGS);
	10->CYCLES;
}

INSTRUCTION	"POPF"		%10011101
{
	CALL PopWord()->FLAGS;
	8->CYCLES;
}

INSTRUCTION	XX11110111	"TEST [#%$2%$1],#%$4%$3"		%00000:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateWord();
	9+11->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { TMP & T };
}

INSTRUCTION	XX00110011	"XOR %M0,[#%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw ^ T }->regw;
}

INSTRUCTION	XX11110110	"TEST [#%$2%$1],#%$3"		%00000:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateByte();
	9+11->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { TMP & T };
}

INSTRUCTION	XX11010001	"SAR %M0,#1"	%11111:regw
{
	DECLARE dummy[16];
	O<-0;
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regw,C,regw[15..15],1) }->regw;
	2->CYCLES;
}

INSTRUCTION	XX11111111	"JMP %M0"	%11100:regw
{
	IP<-regw;
	11->CYCLES;
}

INSTRUCTION	XX10000111	"XCHG %M0,%M1"		%11:regw:regwop2
{
	regw<->regwop2;
	4->CYCLES;
}

INSTRUCTION	XX00101000	"SUB %M1,%M0"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(reglop2,regl,7), C AS CARRY(7), P AS PARITYEVEN { reglop2 - regl }->reglop2;
	3->CYCLES;
}

INSTRUCTION	XX11110110	"IMUL %M0"		%11101:regl
{
	DECLARE lhs[16];
	DECLARE rhs[16];
	lhs<-$0000 ++ AL;
	rhs<-$0000 ++ regl;
	AX<-lhs * rhs;
	C<-(AH!=$00) & (AH!=$FF);
	O<-C;

	80->CYCLES;								# 80 - 98 cycles
}

INSTRUCTION	XX11010011	"SAR %M0,CL"	%11111:regw
{
	DECLARE dummy[16];
	DECLARE fill[16];
	DECLARE shCnt[5];

	shCnt<-CL;

	IF regw[15..15]==1
	{
		fill<-$FFFF;
	}
	IF regw[15..15]==0
	{
		fill<-$0000;
	}
	IF shCnt>=17
	{
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN,C AS BIT(15) { fill }->regw;
	}
	IF (shCnt>0) & (shCnt<17)
	{
		IF shCnt>1
		{
			shCnt<-shCnt-1;
			regw<-ROR(regw,dummy,fill,shCnt);
		}
		AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regw,C,fill,1) }->regw;
	}
	8+((CL[0..4])*$04)->CYCLES;
}

INSTRUCTION	XX00001001	"OR %M1,%M0"	%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regwop2 | regw }->regwop2;
	3->CYCLES;
}

INSTRUCTION	XX10000000	"ADD [#%$2%$1],#%$3"	%00000:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T + TMP}->T;
	CALL StoreByte(DS,EAdisp,T);
	9+17->CYCLES;
}

INSTRUCTION	XX11111111	"CALL %M0"	%11010:regw
{
	CALL PushWord(IP);
	IP<-regw;
	16->CYCLES;
}

INSTRUCTION	"CBW"		%10011000
{
	AX<-$0000++AL;
	2->CYCLES;
}

INSTRUCTION	XX11010001	"ROL %M0,#1"	%11000:regw
{
	regw<-ROL(regw,C,regw[14..14],1);
	O<-C^(regw[15..15]);
	2->CYCLES;
}

INSTRUCTION	XX10000000	"XOR %M0,#%$1"		%11110:regl,B2[8]
{
	DECLARE TMP[8];
	CALL GetImmediateByte()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl ^ TMP }->regl;
	4->CYCLES;
}

INSTRUCTION	XX10000000	"CMP [%M0+#%$2%$1],#%$3"	%10111:memmod,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+10->CYCLES;
	TMP<-CALL GetImmediateByte();
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX00000001	"ADD [#%$2%$1],%M0"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+16->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP + regw }->TMP;
	CALL StoreWord(DS,EAdisp,TMP);
}

INSTRUCTION	XX00000000	"ADD %M1,%M0"		%11:regl:reglop2,B2[8]
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(reglop2,regl,7), C AS CARRY(7), P AS PARITYEVEN { reglop2 + regl }->reglop2;
	3->CYCLES;
}

INSTRUCTION	XX11010001	"ROR %M0,#1"	%11001:regw
{
	regw<-ROR(regw,C,regw[0..0],1);
	O<-(regw[14..14])^(regw[15..15]);
	2->CYCLES;
}

INSTRUCTION	XX10001010	"MOV %M0,[%M1+#%$2%$1]"	%10:regl:memmod,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	memmod+4+8->CYCLES;
	CALL FetchByte(DS,EA)->regl;
}

INSTRUCTION	XX00101010	"SUB %M0,[%M1]"		%00:regl:memmod00
{
	DECLARE TMP[8];
	$0000->EAdisp;
	memmod00+9->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl - TMP }->regl;
}

INSTRUCTION	XX00101011	"SUB %M0,[#%$2%$1]"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
}

INSTRUCTION	XX11110111	"TEST %M0,#%$2%$1"		%11000:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	TMP<-CALL GetImmediateWord();
	AFFECT S AS SIGN, Z AS ZERO, P AS PARITYEVEN { TMP & regw };
	5->CYCLES;
}

INSTRUCTION	XX00000010	"ADD %M0,[#%$2%$1]"	%00:regl:%110,B2[8],B3[8]
{
	DECLARE TMP[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl + TMP }->regl;
}

INSTRUCTION	XX11111111	"DEC [#%$2%$1]"	%00001:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+15->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX10000000	"SUB [#%$2%$1],#%$3"	%00101:%110,B2[8],B3[8],B4[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateByte();
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreByte(DS,EAdisp,T);
	9+17->CYCLES;
}

INSTRUCTION	XX10000001	"CMP [%M0+#%$2%$1],#%$4%$3"	%10111:memmod,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+10->CYCLES;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10001101	"LEA %M0,[%M1+#%$2%$1]"		%10:regw:memmod,B2[8],B3[8]
{
	CALL GetImmediateWord()->EAdisp;
	memmod+4+2->CYCLES;
	regw<-EA;
}

INSTRUCTION	XX10000001	"CMP [%M0],#%$2%$1"	%00111:memmod00,B2[8],B3[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	$0000->EAdisp;
	memmod00+10->CYCLES;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX11111111	"DEC [%M0]"	%00001:memmod00
{
	DECLARE T[16];
	$0000->EAdisp;
	memmod00+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11111111	"DEC [%M0+#%$2%$1]"	%10001:memmod,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10000001	"ADD [%M0+#%$2%$1],#%$4%$3"	%10000:memmod,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateWord();
	memmod+4+17->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T + TMP }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10000001	"AND [%M0+#%$2%$1],#%$4%$3"	%10100:memmod,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateWord();
	memmod+4+17->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { T & TMP }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11111111	"INC [%M0+#%$2%$1]"	%10000:memmod,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11000111 	"MOV [%M0+#%$2%$1],#%$4%$3"	%10000:memmod,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	T<-CALL GetImmediateWord();
	memmod+4+10->CYCLES;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11110110	"NEG [#%$2%$1]"		%00011:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+16->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($00,T,7), P AS PARITYEVEN, C AS CARRY(7) { 0 - T }->T;
	CALL StoreByte(DS,EAdisp,T);
}

INSTRUCTION	XX00111001	"CMP [#%$2%$1],%M0"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,regw,15), C AS CARRY(15), P AS PARITYEVEN { T - regw };
}

INSTRUCTION	XX10000001	"SUB [#%$2%$1],#%$4%$3"	%00101:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreWord(DS,EAdisp,T);
	9+17->CYCLES;
}

INSTRUCTION	XX10000111	"XCHG [#%$2%$1],%M0"		%00:regw:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+17->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	regw<->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX10000001	"SUB [%M0+#%$2%$1],#%$4%$3"	%10101:memmod,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-CALL GetImmediateWord();
	TMP<-CALL GetImmediateWord();
	memmod+4+17->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11000110 	"MOV [%M0],#%$1"	%00000:memmod00,B2[8]
{
	DECLARE T[8];
	$0000->EAdisp;
	T<-CALL GetImmediateByte();
	memmod00+10->CYCLES;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX11000110 	"MOV [%M0+#%$2%$1],#%$3"	%10000:memmod,B2[8],B3[8],B4[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	T<-CALL GetImmediateByte();
	memmod+4+10->CYCLES;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX11111110	"DEC [%M0+#%$2%$1]"	%10001:memmod,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX00000011	"ADD %M0,[%M1+#%$2%$1]"			%10:regw:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
}

INSTRUCTION	XX00111011	"CMP %M0,[%M1+#%$2%$1]"	%10:regw:memmod,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,T,15), C AS CARRY(15), P AS PARITYEVEN { regw - T };
}

INSTRUCTION	XX00101001	"SUB [%M1+#%$2%$1],%M0"	%10:regw:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP - regw }->TMP;
	CALL StoreWord(DS,EA,TMP);
}

INSTRUCTION	XX00000010	"ADD %M0,[%M1+#%$2%$1]"			%10:regl:memmod,B2[8],B3[8]
{
	DECLARE TMP[8];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl + TMP }->regl;
}

INSTRUCTION	XX00000001	"ADD [%M1+#%$2%$1],%M0"			%10:regw:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP + regw }->TMP;
	CALL StoreWord(DS,EA,TMP);
}

INSTRUCTION	XX00101011	"SUB %M0,[%M1+#%$2%$1]"			%10:regw:memmod,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
}

INSTRUCTION	XX10000001	"CMP [%M0+#%$1],#%$3%$2"	%01111:memmod,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+10->CYCLES;
	TMP<-CALL GetImmediateWord();
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP };
}

INSTRUCTION	XX10001101	"LEA %M0,[%M1+#%$1]"		%01:regw:memmod,B2[8]
{
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+2->CYCLES;
	regw<-EA;
}

INSTRUCTION	XX11111111	"DEC [%M0+#%$1]"	%01001:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11111111	"INC [%M0+#%$1]"	%01000:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$0001,15), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10000001	"SUB [%M0+#%$1],#%$3%$2"	%01101:memmod,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-$0000++CALL GetImmediateByte();
	TMP<-CALL GetImmediateWord();
	memmod+4+17->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11111110	"DEC [%M0+#%$1]"	%01001:memmod,B2[8]
{
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T - 1 }->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX00000011	"ADD %M0,[%M1+#%$1]"			%01:regw:memmod,B2[8]
{
	DECLARE TMP[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw + TMP }->regw;
}

INSTRUCTION	XX00111011	"CMP %M0,[%M1+#%$1]"	%01:regw:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,T,15), C AS CARRY(15), P AS PARITYEVEN { regw - T };
}

INSTRUCTION	XX00101001	"SUB [%M1+#%$1],%M0"	%01:regw:memmod,B2[8]
{
	DECLARE TMP[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP - regw }->TMP;
	CALL StoreWord(DS,EA,TMP);
}

INSTRUCTION	XX00000010	"ADD %M0,[%M1+#%$1]"			%01:regl:memmod,B2[8]
{
	DECLARE TMP[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regl,TMP,7), C AS CARRY(7), P AS PARITYEVEN { regl + TMP }->regl;
}

INSTRUCTION	XX00101011	"SUB %M0,[%M1+#%$1]"			%01:regw:memmod,B2[8]
{
	DECLARE TMP[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(regw,TMP,15), C AS CARRY(15), P AS PARITYEVEN { regw - TMP }->regw;
}

INSTRUCTION	XX00101001	"SUB [#%$2%$1],%M0"	%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+16->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP - regw }->TMP;
	CALL StoreWord(DS,EAdisp,TMP);
}

INSTRUCTION	XX00001010	"OR %M0,[#%$2%$1]"		%00:regl:%110,B2[8],B3[8]
{
	DECLARE TMP[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regl | TMP }->regl;
}

INSTRUCTION	XX00111000	"CMP %M1,%M0"	%11:regl:reglop2
{
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(reglop2,regl,7), C AS CARRY(7), P AS PARITYEVEN { reglop2 - regl };
	3->CYCLES;
}

INSTRUCTION	XX11110111	"NEG [%M0]"		%00011:memmod00
{
	DECLARE T[16];
	$0000->EAdisp;
	memmod00+16->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($0000,T,15), P AS PARITYEVEN, C AS CARRY(15) { 0 - T }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX00000001	"ADD [%M1],%M0"		%00:regw:memmod00
{
	DECLARE TMP[16];
	$0000->EAdisp;
	memmod00+16->CYCLES;
	CALL FetchWord(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regw,15), C AS CARRY(15), P AS PARITYEVEN { TMP + regw }->TMP;
	CALL StoreWord(DS,EA,TMP);
}

INSTRUCTION	XX10000001	"ADD [%M0+#%$1],#%$3%$2"	%01000:memmod,B2[8],B3[8],B4[8]
{
	DECLARE TMP[16];
	DECLARE T[16];
	EAdisp<-$0000++CALL GetImmediateByte();
	TMP<-CALL GetImmediateWord();
	memmod+4+17->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,15), C AS CARRY(15), P AS PARITYEVEN { T + TMP }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11110111	"NEG [%M0+#%$1]"		%01011:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($0000,T,15), P AS PARITYEVEN, C AS CARRY(15) { 0 - T }->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX11010001	"SAR [%M0+#%$1],#1"	%01111:memmod,B2[8]
{
	DECLARE dummy[16];
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(T,C,T[15..15],1) }->T;
	CALL StoreWord(DS,EA,T);
	O<-0;
}

INSTRUCTION	XX11110111	"NEG [#%$2%$1]"		%00011:%110,B2[8],B3[8]
{
	DECLARE T[16];
	CALL GetImmediateWord()->EAdisp;
	9+16->CYCLES;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW($0000,T,15), P AS PARITYEVEN, C AS CARRY(15) { 0 - T }->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX00000000	"ADD [%M1],%M0"		%00:regl:memmod00,B2[8]
{
	DECLARE TMP[8];
	$0000->EAdisp;
	memmod00+16->CYCLES;
	CALL FetchByte(DS,EA)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(TMP,regl,7), C AS CARRY(7), P AS PARITYEVEN { TMP + regl }->TMP;
	CALL StoreByte(DS,EA,TMP);
}

INSTRUCTION	XX10000000	"SUB [%M0],#%$1"	%00101:memmod00,B2[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	$0000->EAdisp;
	TMP<-CALL GetImmediateByte();
	memmod00+17->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX11111111	"PUSH [%M0+#%$1]"	%01110:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+16->CYCLES;
	CALL FetchWord(DS,EA)->T;
	CALL PushWord(T);
}

INSTRUCTION	XX11010001	"SHL [%M0+#%$1],#1"	%01100:memmod,B2[8]
{
	DECLARE dummy[16];
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchWord(DS,EA)->T;
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROL(T,C,$0000,1) }->T;
	O<-1;
	IF T[15..15]==C
	{
		O<-0;
	}
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX10001111	"POP [%M0+#%$1]"	%01000:memmod,B2[8]
{
	DECLARE T[16];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+17->CYCLES;
	CALL PopWord()->T;
	CALL StoreWord(DS,EA,T);
}

INSTRUCTION	XX00111000	"CMP [%M1+#%$1],%M0"	%01:regl:memmod,B2[8]
{
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+9->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,regl,7), C AS CARRY(7), P AS PARITYEVEN { T - regl };
}

INSTRUCTION	XX00111000	"CMP [#%$2%$1],%M0"	%00:regl:%110,B2[8],B3[8]
{
	DECLARE T[8];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchByte(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,regl,7), C AS CARRY(7), P AS PARITYEVEN { T - regl };
}

INSTRUCTION	XX10000001	"XOR [#%$2%$1],#%$4%$3"		%00110:%110,B2[8],B3[8],B4[8],B5[8]
{
	DECLARE T[16];
	DECLARE TMP[16];
	EAdisp<-CALL GetImmediateWord();
	9+17->CYCLES;
	CALL GetImmediateWord()->TMP;
	CALL FetchWord(DS,EAdisp)->T;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { T ^ TMP }->T;
	CALL StoreWord(DS,EAdisp,T);
}

INSTRUCTION	XX11111110	"INC [%M0+#%$1]"		%01000:memmod,B2[8]
{
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	memmod+4+15->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,$01,7), P AS PARITYEVEN { T + 1 }->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX11010000	"SAR %M0,#1"	%11111:regl
{
	DECLARE dummy[8];
	O<-0;
	AFFECT S AS SIGN,Z AS ZERO,P AS PARITYEVEN { ROR(regl,C,regl[7..7],1) }->regl;
	2->CYCLES;
}

INSTRUCTION	XX10000000	"SUB [%M0+#%$1],#%$2"	%01101:memmod,B2[8],B3[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	TMP<-CALL GetImmediateByte();
	memmod+4+17->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T - TMP}->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX10000000	"ADD [%M0+#%$1],#%$2"	%01000:memmod,B2[8],B3[8]
{
	DECLARE TMP[8];
	DECLARE T[8];
	$0000++CALL GetImmediateByte()->EAdisp;
	TMP<-CALL GetImmediateByte();
	memmod+4+17->CYCLES;
	CALL FetchByte(DS,EA)->T;
	AFFECT S AS SIGN, Z AS ZERO, A AS CARRY(3), O AS OVERFLOW(T,TMP,7), C AS CARRY(7), P AS PARITYEVEN { T + TMP }->T;
	CALL StoreByte(DS,EA,T);
}

INSTRUCTION	XX10000001	"OR %M0,#%$2%$1"		%11001:regw,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw | TMP }->regw;
	4->CYCLES;
}

INSTRUCTION	XX00100011	"AND %M0,[#%$2%$1]"		%00:regw:%110,B2[8],B3[8]
{
	DECLARE TMP[16];
	CALL GetImmediateWord()->EAdisp;
	9+9->CYCLES;
	CALL FetchWord(DS,EAdisp)->TMP;
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & TMP }->regw;
}

INSTRUCTION	XX00100001	"AND %M1,%M0"			%11:regw:regwop2
{
	AFFECT S AS SIGN, Z AS ZERO, O AS FORCERESET, C AS FORCERESET, P AS PARITYEVEN { regw & regwop2 }->regwop2;
	3->CYCLES;
}


