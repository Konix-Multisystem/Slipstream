# SlipStream DSP
#
# Simplified - Relatively quickly knocked together 
#
# Memory should be internal to chip - I`ll fix later - for now its mirroring values left and right
#
#
# 2 stage pipeline, which means Branch Delay Slot style jumps. Implemented crude Pipeline to simulate



C_FUNC_EXTERN	[16]	DMAGetWord		[32];
C_FUNC_EXTERN		DMASetWord		[32],[16];

C_FUNC_EXTERN	[16]	GetProgWord		[16];
# unsigned char GetWord(unsigned short);
#  Called when the cpu wants to read from memory (note works in word sizes so 1 is address 2&3 in a byte system)
C_FUNC_EXTERN		SetProgWord		[16],[16];
# void SetWord(unsigned short,unsigned short);
#  Called when the cpu wants to write to memory
C_FUNC_EXTERN	[16]	GetDataWord		[16];
# unsigned char GetWord(unsigned short);
#  Called when the cpu wants to read from memory (note works in word sizes so 1 is address 2&3 in a byte system)
C_FUNC_EXTERN		SetDataWord		[16],[16];
# void SetWord(unsigned short,unsigned short);
#  Called when the cpu wants to write to memory
C_FUNC_EXTERN		SetDAC		[8],[16];
# void SetDAC(unsigned char,unsigned short);
#  Called when the DSP writes to the audio DAC (first parameter is DAC mask (bit 0 left, bit 1 right)), second parameter is DAC value

############

DECLARE	PC[16];
DECLARE	IX[16]		ALIAS	IXdc[7]:IX_ACTUAL[9];
DECLARE	MZ0[16];
DECLARE	MZ1[16];
DECLARE	MZ2[16]		ALIAS	%00000000000:C[1]:ZMSB[4];
DECLARE	MODE[16]	ALIAS	MODEdc[9]:TCX[1]:TCYN[1]:M[1]:S[4];
DECLARE	X[16];
DECLARE	AZ[16];

############

DECLARE			DEBUG_PC[16];
DECLARE			CPU_HOLD[8];
############

DECLARE	INTERNAL 	IR[16]		ALIAS	Instruction[5]:Conditional[1]:Index[1]:Address[9];
DECLARE INTERNAL	PIPE[32]	ALIAS	currentInstruction[16]:nextInstruction[16];

DECLARE INTERNAL	MirrorPC[16]	ALIAS	$014A;
DECLARE INTERNAL	MirrorIX[16]	ALIAS	$0141;
DECLARE INTERNAL	MirrorDMA0[16]	ALIAS	$0142;
DECLARE INTERNAL	MirrorDMA1[16]	ALIAS	$0143;
DECLARE INTERNAL	MirrorDMD[16]	ALIAS	$0144;
DECLARE INTERNAL	MirrorMZ0[16]	ALIAS	$0145;
DECLARE INTERNAL	MirrorMZ1[16]	ALIAS	$0146;
DECLARE INTERNAL	MirrorMZ2[16]	ALIAS	$0147;
DECLARE INTERNAL	MirrorMODE[16]	ALIAS	$014B;
DECLARE INTERNAL	MirrorX[16]	ALIAS	$014C;
DECLARE INTERNAL	MirrorAZ[16]	ALIAS	$014D;

DECLARE INTERNAL	DMA1[16]	ALIAS	%0000:DMA_HLD[1]:DMA_RW[1]:DMA_BW[1]:DMA_LOHI[1]:%0000:DMA_ADD_HI[4];
DECLARE INTERNAL	DMA0[16]	ALIAS	DMA_ADD_LO[16];
DECLARE INTERNAL	DMD[16]		ALIAS	DMA_DATA_HI[8]:DMA_DATA_LO[8];

############

FUNCTION STEP
{
	currentInstruction<-nextInstruction;
	DEBUG_PC<-PC;
	nextInstruction<-CALL GetProgWord(PC);
	PC<-PC+1;
	IR<-currentInstruction;
	CALL SetDataWord(MirrorPC,PC);

	IF Index
	{
		Address<-Address + IX_ACTUAL;
	}

	IF (~Conditional) | C
	{
		EXECUTE	Instruction;
	}
}

FUNCTION RESET
{
	CPU_HOLD<-0;
	nextInstruction<-$F000;		# On reset fill start of pipe with NOP
	PC<-0;
	CALL SetDataWord(MirrorPC,PC);
}

FUNCTION DoDMA
{
	#DEBUG_TRACE DMA1,DMA0;		# Some sort of state machine for these transfers... no idea how long they are supposed to take, for now - we just do the action in line (possibly ~8-10 DSP cycles - based on delay loop)

	IF DMA_BW
	{
		#DEBUG_TRACE "DMA Byte Width Not Supported Yet!";
	}
	IF ~DMA_BW
	{
		IF DMA_RW
		{
			DECLARE ADDR[20]	ALIAS	UPPER[4]:LOWER[16];
			UPPER<-DMA1[0..3];
			LOWER<-DMA0;
			DMD<-CALL DMAGetWord(ADDR);
		}
		IF ~DMA_RW
		{
			DECLARE ADDR[20]	ALIAS	UPPER[4]:LOWER[16];
			UPPER<-DMA1[0..3];
			LOWER<-DMA0;
			CALL DMASetWord(ADDR,DMD);
		}
	}
}

############

INSTRUCTION	"MOV. %$1,MZ1"		%00001
{
	CALL SetDataWord(Address,MZ1);
}

INSTRUCTION	"MOV. MZ1,%$1"		%00011
{
	MZ1<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorMZ1,MZ1);
}

INSTRUCTION	"CCF."			%00100
{
	C<-~C;
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"MOV. DMA0,%$1"		%00101
{
	DMA0<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorDMA0,DMA0);
	CALL DoDMA();
}

INSTRUCTION	"MOV. DMA1,%$1"		%00110
{
	DMA1<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorDMA1,DMA1);
	CPU_HOLD<-DMA_HLD;				# HLD status set/cleared on writes to this
}

INSTRUCTION	"MOV. %$1,DMD"		%01000
{
	CALL SetDataWord(Address,DMD);
}

INSTRUCTION	"MAC. %$1,X"		%01001
{
	# Multiplier is 16x16 which would generate a 32bit result, but carry is taken from 35-36 so will perform calculation as 40x40 bit?
	DECLARE xExt[40];
	DECLARE tExt[40];
	DECLARE result[40];
	DECLARE mac[40];

	IF TCX
	{
		xExt<-$0000000000++X;
	}
	IF ~TCX
	{
		xExt<-X;
	}
	IF TCYN
	{
		tExt<-CALL GetDataWord(Address);
	}
	IF ~TCYN
	{
		tExt<-$0000000000++CALL GetDataWord(Address);
	}

	#DEBUG_TRACE "Operands for multiply",BASE 16,xExt,tExt;

	result<-xExt * tExt;
	MZ0->mac[0..15];
	MZ1->mac[16..31];
	MZ2[0..3]->mac[32..35];

	#DEBUG_TRACE "Operands for add",BASE 16,result,mac;

	mac + result->result;

	#DEBUG_TRACE BASE 16,result;

	result[0..15]->MZ0;
	result[16..31]->MZ1;
	result[32..35]->MZ2[0..3];
	C<-result[36];
	CALL SetDataWord(MirrorMZ0,MZ0);
	CALL SetDataWord(MirrorMZ1,MZ1);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"MOV. MODE,%$1"		%01010
{
	MODE<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorMODE,MODE);
}

INSTRUCTION	"MOV. IX,%$1"		%01011
{
	IX<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorIX,IX);
}

INSTRUCTION	"MOV. X,%$1"		%01101
{
	X<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorX,X);
}

INSTRUCTION	"MOV. %$1,X"		%01110
{
	CALL SetDataWord(Address,X);
}

INSTRUCTION	"MULT. %$1,X"		%01111
{
	# Multiplier is 16x16 which would generate a 32bit result, but carry is taken from 35-36 so will perform calculation as 40x40 bit?
	DECLARE xExt[40];
	DECLARE tExt[40];
	DECLARE result[40];

	IF TCX
	{
		xExt<-$0000000000++X;
	}
	IF ~TCX
	{
		xExt<-X;
	}
	IF TCYN
	{
		tExt<-CALL GetDataWord(Address);
	}
	IF ~TCYN
	{
		tExt<-$0000000000++CALL GetDataWord(Address);
	}

	#DEBUG_TRACE "Operands for multiply",BASE 16,xExt,tExt;

	result<-xExt * tExt;

	#DEBUG_TRACE BASE 16,result;

	result[0..15]->MZ0;
	result[16..31]->MZ1;
	result[32..35]->MZ2[0..3];
	C<-result[36];
	CALL SetDataWord(MirrorMZ0,MZ0);
	CALL SetDataWord(MirrorMZ1,MZ1);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"ADD. %$1"		%10000
{
	DECLARE tmp[16];
	CALL GetDataWord(Address)->tmp;

	AFFECT C AS CARRY(15) { tmp + X } -> AZ;
	CALL SetDataWord(MirrorAZ,AZ);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"SUB. %$1"		%10001
{
	DECLARE tmp[16];
	CALL GetDataWord(Address)->tmp;

	AFFECT C AS NOCARRY(15) { X - tmp } -> AZ;
	CALL SetDataWord(MirrorAZ,AZ);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"AND. %$1"		%10010
{
	CALL GetDataWord(Address) & X->AZ;
	CALL SetDataWord(MirrorAZ,AZ);
}

INSTRUCTION	"OR. %$1"		%10011
{
	CALL GetDataWord(Address) | X->AZ;
	CALL SetDataWord(MirrorAZ,AZ);
}

INSTRUCTION	"ADC. %$1"		%10100
{
	DECLARE tmp[16];
	CALL GetDataWord(Address)->tmp;

	AFFECT C AS CARRY(15) { tmp + X + C } -> AZ;
	CALL SetDataWord(MirrorAZ,AZ);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"SBC. %$1"		%10101
{
	DECLARE tmp[16];
	CALL GetDataWord(Address)->tmp;

	AFFECT C AS NOCARRY(15) { (X - tmp)-C } -> AZ;
	CALL SetDataWord(MirrorAZ,AZ);
	CALL SetDataWord(MirrorMZ2,MZ2);
}

INSTRUCTION	"MOV. %$1,AZ"		%10110
{
	CALL SetDataWord(Address,AZ);
	CALL SetDataWord(MirrorAZ,AZ);
}

INSTRUCTION	"MOV. DAC1,%$1"		%11001
{
	CALL SetDAC(1,CALL GetDataWord(Address));
}

INSTRUCTION	"MOV. DAC2,%$1"		%11010
{
	CALL SetDAC(2,CALL GetDataWord(Address));
}

INSTRUCTION	"MOV. DAC12,%$1"	%11011
{
	CALL SetDAC(3,CALL GetDataWord(Address));
}

INSTRUCTION	"MOV. PC,%$1"		%11101
{
	PC<-CALL GetDataWord(Address);
	CALL SetDataWord(MirrorPC,PC);
}

INSTRUCTION	"NOP."			%11110
{

}


INSTRUCTION	"INTRUDE."		%11111
{
	# TODO
}


